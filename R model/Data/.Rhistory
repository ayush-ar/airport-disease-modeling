if (plant_1[i] == 0){
plant_2_wins <- plant_2_wins + 1
}
if (plant_2[i] == 0){
plant_1_wins <- plant_1_wins + 1
}
if (plant_1[i] == 0 | plant_2[i] == 0){
time.max = i
break
}
}
# Visualization and Diversity Report
#plot(plant_1, type = "l", xlab = "t", ylab = "n",
#     main = "Plant Populations",
#     col = "red",
#     ylim = c(0, world_length^2 + 200),
#     xlim = c(0, time.max)
#)
#lines(plant_2, col = "blue", type = "l")
#abline(h = world_length^2, col = "green")
#legend(0, (world_length^2 + 200), legend = c("Plant 1","Plant 2"), fill = c("red","blue"))
#d = (plant_1[time.max]/(plant_2[time.max]+plant_1[time.max]))^2 + (plant_2[time.max]/(plant_1[time.max]+plant_2[time.max]))^2
#cat("Diversity", d,
#    "\n", "Plant 1 End Population", plant_1[time.max],
#    "\n", "Plant 2 End Population", plant_2[time.max])
}
# PLANT R SIMULATION
# VERSION 5
# Patt, Taylor, Yager
# Last Updated: Dec. 4th, 2013
#
repetitions = 10
plant_1_wins <- 0
plant_2_wins <- 0
for (q in 1:repetitions){
time = 10000
world_length = 20
plant_1_starting = 10
plant_2_starting = 60
mortality = 0.1
poll.eff = 0.4
# Torus Function
torus = function(n) {
return((((n-1) + world_length) %% world_length) + 1)
}
# Matrix to Vector Function
mat.conv = function(xpos,ypos){
return(
(world_length*ypos - world_length) + xpos
)
}
# Timeloop Start
plant_1 = vector(length = time)
plant_2 = vector(length = time)
plant_1[1] = plant_1_starting
plant_2[1] = plant_2_starting
world <- F
world[0:world_length^2] <- 0
world[sample(x = world_length^2, size = plant_1[1])] <- 1
world[sample(x = world_length^2, size = plant_2[1])] <- 2
world.matrix <- matrix(world, ncol = world_length, nrow = world_length)
for (i in 1:time){
# Mortality
mort.order = sample(x = length(world.matrix), size = length(world.matrix))
for (z in 1:world_length^2){
if (mortality == 0){
break
}
if (world.matrix[mort.order[z]] != 0){
kill = sample(x = 10, size = 10*mortality)
if (kill == sample(x = 10, size = 1)){
world.matrix[mort.order[z]] <- 0
}
}
}
# Set Order for Continuous Pollination in Discrete Timestep
eval.order = sample(x = length(world.matrix), size = length(world.matrix))
# Run Evaluation Order and Plant Spawn
for (k in 1:world_length^2){
xpos = (eval.order[k] %% world_length)
if (xpos == 0){
xpos <- world_length
}
ypos = (eval.order[k] / world_length)
pollinate = sample(x = 10, size = 10 * poll.eff)
if (world.matrix[eval.order[k]] != 0
&& pollinate == sample(x = 10, size = 1)
){
plant <- world.matrix[eval.order[k]]
for (x in -1:1){
for(y in -1:1){
if (x == 0 && y == 0){
} else {
if (world.matrix[torus(xpos + x), torus(ypos + y)] == 0){
world.matrix[torus(xpos + x), torus(ypos + y)] <- plant
}
}
}
}
}
}
# Population Counter
world.vector = as.vector(world.matrix)
plant_1_count <- 0
plant_2_count <- 0
for (w in 1:length(world.vector)){
if (world.vector[w] == 1){
plant_1_count = plant_1_count + 1
}
if (world.vector[w] == 2){
plant_2_count = plant_2_count + 1
}
}
plant_1[i] = plant_1_count
plant_2[i] = plant_2_count
#  image(world.matrix,
#        col = c("black","red","blue"), main = paste("Timestep ",i))
if (plant_1[i] == 0){
plant_2_wins <- plant_2_wins + 1
}
if (plant_2[i] == 0){
plant_1_wins <- plant_1_wins + 1
}
if (plant_1[i] == 0 | plant_2[i] == 0){
time.max = i
break
}
}
# Visualization and Diversity Report
#plot(plant_1, type = "l", xlab = "t", ylab = "n",
#     main = "Plant Populations",
#     col = "red",
#     ylim = c(0, world_length^2 + 200),
#     xlim = c(0, time.max)
#)
#lines(plant_2, col = "blue", type = "l")
#abline(h = world_length^2, col = "green")
#legend(0, (world_length^2 + 200), legend = c("Plant 1","Plant 2"), fill = c("red","blue"))
#d = (plant_1[time.max]/(plant_2[time.max]+plant_1[time.max]))^2 + (plant_2[time.max]/(plant_1[time.max]+plant_2[time.max]))^2
#cat("Diversity", d,
#    "\n", "Plant 1 End Population", plant_1[time.max],
#    "\n", "Plant 2 End Population", plant_2[time.max])
}
setwd("~/Documents/Uni/Research")
data = read.csv("DeltaResults.csv")
plot(data)
plot(data$PP1W, data$Delta, ylab="Delta")
plot(data,
xlab="Difference in Starting Population Size (Plant One Compared to Plant Two)",
ylab="Percent Win (10 Trials At Population Size)"
)
plot(data,
xlab="Difference in Starting Population Size \
(Plant One Compared to Plant Two)",
ylab="Percent Win (10 Trials At Population Size)",
main="Starting Population Bias"
)
plot(data,
xlab="   Difference in Starting Population Size \
(Plant One Compared to Plant Two)",
ylab="Percent Win\(10 Trials At Population Size)",
main="Starting Population Bias"
)
plot(data,
xlab="   Difference in Starting Population Size \
(Plant One Compared to Plant Two)",
ylab="Percent Win \ (10 Trials At Population Size)",
main="Starting Population Bias"
)
plot(data,
xlab="   Difference in Starting Population Size \
(Plant One Compared to Plant Two)",
ylab="Percent Win \
(10 Trials At Population Size)",
main="Starting Population Bias"
)
ylab="Percent Win
plot(data,
xlab="   Difference in Starting Population Size \
(Plant One Compared to Plant Two)",
ylab="Percent Win
(10 Trials At Population Size)",
main="Starting Population Bias"
)
plot(data,
xlab="   Difference in Starting Population Size \
(Plant One Compared to Plant Two)",
ylab="Percent Win (10 Trials At Population Size)",
main="Starting Population Bias"
)
plot(data,
xlab="   Difference in Starting Population Size
(Plant One Compared to Plant Two)",
ylab="Percent Win (10 Trials At Population Size)",
main="Starting Population Bias"
)
plot(data,
xlab="    Difference in Starting Population Size
(Plant One Compared to Plant Two)",
ylab="Percent Win (10 Trials At Population Size)",
main="Starting Population Bias"
)
plot(data,
xlab="Difference in Starting Population Size\n(Plant One Compared to Plant Two)",
ylab="Percent Win\n(10 Trials At Population Size)",
main="Starting Population Bias"
)
plot(data,
xlab="Difference in Starting Population Size\n(Plant One Compared to Plant Two)",
ylab="Percent Win (10 Trials At Population Size)",
main="Starting Population Bias"
)
setwd("~/Documents/Uni/Research")
data = read.csv("DeltaResults.csv")
plot(data,
xlab="Difference in Starting Population Size\n(Plant One Compared to Plant Two)",
ylab="Percent Win (10 Trials At Population Size)",
main="Starting Population Bias"
)
data
plot(data$Delta, data$PP1W,
xlab="",
ylab="Percent Win (10 Trials At Population Size)",
main="Starting Population Bias"
)
plot(data$Delta, asin(data$PP1W),
xlab="",
ylab="Percent Win (10 Trials At Population Size)",
main="Starting Population Bias"
)
asin(1)
asin(.9)
plot(data$Delta, asin(data$PP1W/100)*2/pi
xlab="",
ylab="Percent Win (10 Trials At Population Size)",
main="Starting Population Bias"
)
plot(data$Delta, asin(data$PP1W/100)*2/pi,
xlab="",
ylab="Percent Win (10 Trials At Population Size)",
main="Starting Population Bias"
)
plot(data$Delta, asin(sqrt(data$PP1W)),
xlab="",
ylab="Percent Win (10 Trials At Population Size)",
main="Starting Population Bias"
)
plot(data$Delta, asin(data$PP1W),
xlab="",
ylab="Percent Win (10 Trials At Population Size)",
main="Starting Population Bias"
)
plot(data$Delta, arc(sqrt(data$PP1W))
xlab="Difference in Starting Population Size\n(Plant One Compared to Plant Two)",
ylab="Percent Win (10 Trials At Population Size)",
main="Starting Population Bias"
)
plot(data$Delta, arc(sqrt(data$PP1W)),
xlab="Difference in Starting Population Size\n(Plant One Compared to Plant Two)",
ylab="Arcsin Sqrt. Transformed Win Proportion",
main="Starting Population Bias"
)
plot(data$Delta, asin(sqrt(data$PP1W)),
xlab="Difference in Starting Population Size\n(Plant One Compared to Plant Two)",
ylab="Arcsin Sqrt. Transformed Win Proportion",
main="Starting Population Bias"
)
shapiro.test(data$Delta)
shapiro.test(asin(sqrt(data$PP1W)))
box(asin(sqrt(data$PP1W)))
boxplot(asin(sqrt(data$PP1W)))
shapiro.test(asin(sqrt(data$PP1W)))
wilcox.test(data$Delta, asin(sqrt(data$PP1W))
)
wilcox.test(data$Delta, asin(sqrt(data$PP1W)))
wilcox.test(data$Delta, asin(sqrt(data$PP1W)), paired=T)
cor(data$Delta, asin(sqrt(data$PP1W)), method="Spearman")
cor(data$Delta, asin(sqrt(data$PP1W)), method="spearman")
cor.test(data$Delta, asin(sqrt(data$PP1W)), method="spearman")
cor.test(data$Delta, asin(sqrt(data$PP1W)), method="spearman", alternative="two.sided")
cor.test(data$Delta, data$PP1W, method="spearman", alternative="two.sided")
cor.test(data$Delta, asin(sqrt(data$PP1W)), method="spearman", alternative="two.sided")
plot(data$Delta, asin(sqrt(data$PP1W)),
xlab="Difference in Starting Population Size\n(Plant One Compared to Plant Two)",
ylab="Win Proportion (Arcsin Sqrt Transformation",
main="Starting Population Bias"
)
plot(data$Delta, asin(sqrt(data$PP1W)),
xlab="Difference in Starting Population Size\n(Plant One Compared to Plant Two)",
ylab="Win Proportion (Arcsin Sqrt Transformation)",
main="Starting Population Bias"
)
cor.test(data$Delta, asin(sqrt(data$PP1W)), method="spearman", alternative="two.sided")
abs(0)
exponent = function(a,b)
{
if (b > 0){
output = 1
i = 0
while ( i < b ){
output = output*a
i = i + 1
}
return (output)
} else {
output = 1
i = 0
while (i < abs(b)){
output = output*a
i = i + 1
}
return (1/output)
}
}
exponent(3,0)
a = 3
b = 0
output = 1
i = 0
while (i < abs(b)){
output = output*a
i = i + 1
}
return (1/output)
}
output = 1
i = 0
while (i < abs(b)){
output = output*a
i = i + 1
}
exponent = function(a,b)
{
output = 1
i = 0
while ( i < b ){
output <- output*a
i <- i + 1
}
if (b > 0){
}
return (output)
} else {}
return (1/output)
}
exponent = function(a,b)
{
output = 1
i = 0
while ( i < b ){
output <- output*a
i <- i + 1
}
if (b > 0){
return (output)
} else {
return (1/output)
}
}
9^-6
exponent(9,-6)
6^6
exponent(6,6)
exponent = function(a,b)
{
output = 1
i = 0
while ( i < abs(b) ){
output <- output*a
i <- i + 1
}
if (b > 0){
return (output)
} else {
return (1/output)
}
}
9^-6
exponent(9,-6)
plot(log(x^3))
draw(log(x^3))
curve(log(x^3))
curve(log(x^3), ylim = c(0,10))
curve(log(x^3), ylim = c(0,10), xlim = c(0,5))
curve(log(x^3), ylim = c(0,10), xlim = c(0,10))
curve(log(x^3), ylim = c(-10,10), xlim = c(-10,10))
curve(log(x^2), ylim = c(-10,10), xlim = c(-10,10))
curve(log10(x^2), ylim = c(-10,10), xlim = c(-10,10))
curve(log10(x^3), ylim = c(-10,10), xlim = c(-10,10))
curve(log10(x^3), ylim = c(0,10), xlim = c(0,10))
setwd("~/Documents/Uni/Research/airport_flu_modeling/R model/Data")
# Epidemiology of the Airways
# By Nick Yager, Matthew Taylor
# Last Update: Jan 31th, 2014
#
#
# Purpose: To build a working network model to simulate a disease/pathogen using the
# air travel system to propogate.
# Libraries
library(igraph)
# Read in data files.
main.data = read.csv("airports.csv")
route.data = read.csv("flight.data.csv")
# Fake Vertice Fix
vertices <- main.data$ID
vertices <- matrix(vertices)
# Make Network Code
air.net <- graph.empty()
air.net <- add.vertices(air.net, nrow(vertices),
ID = as.character(vertices[,1])
)
edges <- matrix(c(route.data[,2], route.data[,4]), nc = 2)
#edges <- edges[complete.cases(edges),] # Gets rid of NAs
air.net <- add.edges(air.net, t(edges),
from = edges[,1],
to = edges[,2]
)
vertices <- 1:length(main.data$ID[length(main.data$ID)])
# Epidemiology of the Airways
# By Nick Yager, Matthew Taylor
# Last Update: Jan 31th, 2014
#
#
# Purpose: To build a working network model to simulate a disease/pathogen using the
# air travel system to propogate.
# Libraries
library(igraph)
# Read in data files.
main.data = read.csv("airports.csv")
route.data = read.csv("flight.data.csv")
# Fake Vertice Fix
vertices <- 1:length(main.data$ID[length(main.data$ID)])
vertices <- matrix(vertices)
# Make Network Code
air.net <- graph.empty()
air.net <- add.vertices(air.net, nrow(vertices),
ID = as.character(vertices[,1])
)
edges <- matrix(c(route.data[,2], route.data[,4]), nc = 2)
#edges <- edges[complete.cases(edges),] # Gets rid of NAs
air.net <- add.edges(air.net, t(edges),
from = edges[,1],
to = edges[,2]
)
main.data = read.csv("airports.csv")
route.data = read.csv("routes.csv")
# Fake Vertice Fix
vertices <- 1:length(main.data$ID[length(main.data$ID)])
vertices <- matrix(vertices)
# Make Network Code
air.net <- graph.empty()
air.net <- add.vertices(air.net, nrow(vertices),
ID = as.character(vertices[,1])
)
edges <- matrix(c(route.data[,2], route.data[,4]), nc = 2)
#edges <- edges[complete.cases(edges),] # Gets rid of NAs
air.net <- add.edges(air.net, t(edges),
from = edges[,1],
to = edges[,2]
)
vertices <- 1:length(main.data$ID[length(main.data$ID)])
vertices <- matrix(vertices)
# Make Network Code
air.net <- graph.empty()
air.net <- add.vertices(air.net, nrow(vertices),
ID = as.character(vertices[,1])
)
edges <- matrix(c(route.data[,2], route.data[,4]), nc = 2)
edges <- edges[complete.cases(edges),] # Gets rid of NAs
air.net <- add.edges(air.net, t(edges),
from = edges[,1],
to = edges[,2]
)
length(main.data$ID[length(main.data$ID)])
View(main.data)
vertices <- 1:length(main.data$ID[length(main.data)])
length(main.data$ID)
vertices <- 1:main.data$ID[length(main.data$ID)]
vertices <- matrix(vertices)
# Make Network Code
air.net <- graph.empty()
air.net <- add.vertices(air.net, nrow(vertices),
ID = as.character(vertices[,1])
)
edges <- matrix(c(route.data[,2], route.data[,4]), nc = 2)
edges <- edges[complete.cases(edges),] # Gets rid of NAs
air.net <- add.edges(air.net, t(edges),
from = edges[,1],
to = edges[,2]
)
air.net
degree.distrobution(air.net)
degree.distribution(air.net)
plot(degree.distribution(air.net))
betweenness(air.net)
avg(betweenness(air.net))
mean(betweenness(air.net))
between = betweenness(air.net)
plot(between)
order(between)
sort(between,decreasing = F)
between <- betweenness(air.net, normalized = F)
sort(between,decreasing = F)
between <- betweenness()
graph(air.net)
graph.density(air.net)
gamma = 5
beta <- graph.density/gamma
beta <- graph.density(air.net)/gamma
beta = (length(edges)/length(vertices))-1
Ro <- beta/gamma
Ro
