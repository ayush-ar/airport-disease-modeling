# depicting when the CDC would have to arrive to save/cure half the people.
# THEY HAVE THE ANTIDOTE! WHOOO! Title this graph "Figure 2" and don't forget
# proper axis labels and a legend.
# Insert the code below that allows you to determine where to put the line:
fifty = out.dat$time[out.dat$R <= 0.5]
fifty = fifty[length(fifty)]
# Place the code for the your new graph, line and legend here:
# (hint: the abline command might help here.)
matplot(out.dat[,1], out.dat[,2:5], type = "l", lty = 1, lwd = 2,
main = "Figure 2", ylab = "Number of Individuals", xlab = "Time",
ylim = c(0,1)
)
legend("right", c("Susceptible", "Latent","Infectious", "Removed"),
col = 1:4, lty = 1, lwd = 2)
abline(v = fifty, col = "indian red", lwd = 3, lty = 1)
times = seq(1,500, by = 1)
last.man = as.data.frame(ode(func = SEIR, y = init.values, parms = pars, time = times))
tail(last.man)
prop.val = 1/500
last.day = last.man$time[last.man$R <= prop.value]
prop.val = 1/500
last.day = last.man$time[last.man$R <= prop.val]
1/500
last.day = last.man$time[last.man$R >= prop.val]
last.day
tail(last.man)
last.day = last.man$time[last.man$R >= (1-prop.val)]
last.day
last.day = last.man$time[last.man$R <= (1-prop.val)]
last.day
last.man[66]
last.man$R[66]
last.man$R[67]
last.man <- lastman[,2:5] * 500
last.man <- last.man[,2:5] * 500
View(last.man)
last.day = last.man$time[last.man$R <= 499]
last.day = last.man$time[last.man$R <= 499]
View(last.man)
last.man <- matrix(c(last.man$time, last.man[,2:5] * 500))
last.man <- data.fram(c(last.man$time, last.man[,2:5] * 500))
last.man <- data.frame(c(last.man$time, last.man[,2:5] * 500))
last.man[,5] <- times
View(last.man)
last.day = last.man$time[last.man$I <= 1]
View(last.man)
last.day = last.man$V5[last.man$I <= 1]
last.man$I[401]
last.man = as.data.frame(ode(func = SEIR, y = init.values, parms = pars, time = times))
last.man <- last.man[,2:5] * 500
last.man[,5] <- times
last.day = last.man$V5[last.man$I <= 1]
View(last.man)
last.man <- last.man[,2:5] * 500
View(last.man)
times = seq(1,500, by = 1)
last.man = as.data.frame(ode(func = SEIR, y = init.values, parms = pars, time = times))
last.man <- last.man[,2:5] * 500
View(last.man)
last.day = last.man$I[last.man$I <= 1]
last.day = last.man$I[last.man$I >= 1]
tail.last.day
tail(last.day)
last.day
last.man$I[100]
last.man$I[101]
last.man$I[104]
last.man$I[103]
View(last.man)
inf.zero = last.man$I[last.man$I <= 0]
inf.zero = last.man$I[last.man$I <= 1]
last.man[,5] = times
View(last.man)
inf.zero = last.man$V5[last.man$I <= 1]
inf.zero <- inf.zero <= 100
times = seq(1,500, by = 1)
init.values = c(S = 499, E = 1, I = 0, R = 0)
last.man = as.data.frame(ode(func = SEIR, y = init.values, parms = pars, time = times))
View(last.man)
times = seq(1,500, by = 1)
pars = c( birth = 0.001,                # Birth rate into S
Bs = 1/500,                # Bs = rate of infection
Be = 1/3,                    # Latent to infectious
mu = 1/13 )                   # death rate due to infection
init.values = c(S = 499, E = 1, I = 0, R = 0)
last.man = as.data.frame(ode(func = SEIR, y = init.values, parms = pars, time = times))
View(last.man)
last.day <- last.day[-5,]
last.man <- last.man[-5,]
View(last.man)
times = seq(1,500, by = 1)
pars = c( birth = 0.001,
Bs = 1/500,
Be = 1/3,
mu = 1/13 )
init.values = c(S = 499, E = 1, I = 0, R = 0)
last.man = as.data.frame(ode(func = SEIR, y = init.values, parms = pars, time = times))
last.man <- last.man[-1:5,]
last.man <- last.man[-(1:5),]
View(last.man)
View(last.man)
last.day = last.man$time[last.man$I >= 1]
last.day <- length(last.day) + length(1:5)
last.day
cat("The last day on which the population will have ONE person left is ",last.day)
cat("The last day on which the population will have ONE person left is Day",last.day)
cat("The last day, on which the population will have ONE person left, is Day",last.day)
last.man$S[last.man$time[50]]
View(last.man)
times = seq(1,500, by = 1)
pars = c( birth = 0.001,
Bs = 1/500,
Be = 1/3,
mu = 1/13 )
init.values = c(S = 499, E = 1, I = 0, R = 0)
last.man = as.data.frame(ode(func = SEIR, y = init.values, parms = pars, time = times))
last.day <- last.man[-(1:5),]
last.day = last.man$time[last.man$I >= 1]
last.day <- length(last.day) + length(1:5)
last.day
last.man$I[104]
last.day <- last.man[-(1:5),]
View(last.day)
last.day = last.man$time[last.man$I >= 1]
times = seq(1,500, by = 1)
pars = c( birth = 0.001,
Bs = 1/500,
Be = 1/3,
mu = 1/13 )
init.values = c(S = 499, E = 1, I = 0, R = 0)
last.man = as.data.frame(ode(func = SEIR, y = init.values, parms = pars, time = times))
last.man2 <- last.man[-(1:5),]
View(last.man2)
last.day = last.man2$time[last.man$I >= 1]
last.day <- length(last.day) + length(1:5)
last.man <- last.man[-(1:5),]
times = seq(1,500, by = 1)
pars = c( birth = 0.001,
Bs = 1/500,
Be = 1/3,
mu = 1/13 )
init.values = c(S = 499, E = 1, I = 0, R = 0)
last.man = as.data.frame(ode(func = SEIR, y = init.values, parms = pars, time = times))
last.day <- last.man[-(1:5),]
last.day = last.day$time[last.day$I >= 1]
last.day <- length(last.day) + length(1:5)
last.man$S[50] + last.man$E[50] + last.man$I[50]
floor(last.man$S[50] + last.man$E[50] + last.man$I[50])
cat("On Day 50 there will be",floor(last.man$S[50] + last.man$E[50] + last.man$I[50]),"people left.",
"\n", "The day the living population falls below 1 individual is", last.day + 1,".")
cat("On Day 50 there will be",floor(last.man$S[50] + last.man$E[50] + last.man$I[50]),"people left.",
"\n", "The day the living population falls below 1 individual is Day", last.day + 1)
## SIR Model
## MBS Spring 2014
## Chris Leary
## Load in the DiffEq solver
## _One time only_, you need to install the package deSolve by running
## the next command:
#  install.packages("deSolve") # Comment this line out after you have executed it once
## One time per session, you need to load the package into R by running this
## next line, but it doesn't hurt to run it often...
library(deSolve)
# Clear the memory
rm(list=ls())
#  First, the parameters for our model:
pars <- c( beta	= .6,  	  # contact rate
gamma	= .1,   # recovery rate
mu = 1/365     # birth/death
)
#	Then, the initial values of each state variable:
init.values <- c(S = .999, I = .001, R = 0)
#	The times we want to see
times <- seq(0, 100, by = 1)
#	Now we can define the differential equation model:
SIR <- function(time, y.values, parameters) {
with(as.list(c(y.values, parameters)), {
dS.dt = - beta * S * I - mu * S + mu * (S + I + R)
dI.dt = beta * S * I - gamma * I - mu * I
dR.dt = gamma * I - mu * I
return(list(c(dS.dt, dI.dt, dR.dt)))
})
}
#	Having defined everything, now we ask the program ode
#	to actually solve the system:
out <- as.data.frame(ode(func = SIR, y = init.values,
parms = pars, times = times))
#	And now we can make a nice plot of our results:
matplot(out$time, out[ ,2:4], type = "l", xlab = "time",
ylab = "proportion of the population", main = "SIR Model", lwd = 3,
lty = 1, ylim=c(0,1))
legend("right", c("Susceptible", "Infectious", "Removed"),
col = 1:3, lty = 1, lwd = 3)
tail(out)
##
##
##
##
##  Look at R_\infty, the percentage of the population that is infectious during
##  the epidemic.  We can estimate this by finding a root of the equation
##  1 - x - e^(-R0x)
Beta <- as.numeric(pars[1])
Gamma <- as.numeric(pars[2])
R0 <- Beta/Gamma
f <- function(x){
1 - x - exp(-R0 * x)
}
f(1)
uniroot(f, c(.0001,1))  # Finds the root of a single variable function, looking in the given interval
## SIR Model
## MBS Spring 2014
## Chris Leary
## Load in the DiffEq solver
## _One time only_, you need to install the package deSolve by running
## the next command:
#  install.packages("deSolve") # Comment this line out after you have executed it once
## One time per session, you need to load the package into R by running this
## next line, but it doesn't hurt to run it often...
library(deSolve)
# Clear the memory
rm(list=ls())
#  First, the parameters for our model:
pars <- c( beta	= .6,  	  # contact rate
gamma	= .1,   # recovery rate
mu = 1/365     # birth/death
)
#	Then, the initial values of each state variable:
init.values <- c(S = .999, I = .001, R = 0)
#	The times we want to see
times <- seq(0, 1000, by = 1)
#	Now we can define the differential equation model:
SIR <- function(time, y.values, parameters) {
with(as.list(c(y.values, parameters)), {
dS.dt = - beta * S * I - mu * S + mu * (S + I + R)
dI.dt = beta * S * I - gamma * I - mu * I
dR.dt = gamma * I - mu * I
return(list(c(dS.dt, dI.dt, dR.dt)))
})
}
#	Having defined everything, now we ask the program ode
#	to actually solve the system:
out <- as.data.frame(ode(func = SIR, y = init.values,
parms = pars, times = times))
#	And now we can make a nice plot of our results:
matplot(out$time, out[ ,2:4], type = "l", xlab = "time",
ylab = "proportion of the population", main = "SIR Model", lwd = 3,
lty = 1, ylim=c(0,1))
legend("right", c("Susceptible", "Infectious", "Removed"),
col = 1:3, lty = 1, lwd = 3)
tail(out)
##
##
##
##
##  Look at R_\infty, the percentage of the population that is infectious during
##  the epidemic.  We can estimate this by finding a root of the equation
##  1 - x - e^(-R0x)
Beta <- as.numeric(pars[1])
Gamma <- as.numeric(pars[2])
R0 <- Beta/Gamma
f <- function(x){
1 - x - exp(-R0 * x)
}
f(1)
uniroot(f, c(.0001,1))  # Finds the root of a single variable function, looking in the given interval
tail(out)
plot(airnet)
library(deSolve)
library(igraph)
# Read in data files.
airports = read.csv("airports.csv")
routes = read.csv("routes.csv")
# Initial Parameters
time = 50       # Length of Simulation
NCR = 0.3       # Prob of Neighbor Contraction
i.time = 4      # Infectious Length
i.start = 1     # Number of airports starting with pathogen
# Generate the network
airnet.edge.df <- data.frame(from = routes$FromNum, to = routes$ToNum)
airnet.edge.df <- airnet.edge.df[complete.cases(airnet.edge.df),]
airports = read.csv("airports.csv")
setwd("~/Documents/Uni/Research/airport_flu_modeling/R model/Data")
# Epidemiology of the Airways
# By Nick Yager, Matthew Taylor
# Last Update: Jan 31th, 2014
#
#
# Purpose: To build a working network model to simulate a disease/pathogen using the
# air travel system to propogate.
# Libraries
library(deSolve)
library(igraph)
# Read in data files.
airports = read.csv("airports.csv")
routes = read.csv("routes.csv")
# Initial Parameters
time = 50       # Length of Simulation
NCR = 0.3       # Prob of Neighbor Contraction
i.time = 4      # Infectious Length
i.start = 1     # Number of airports starting with pathogen
# Generate the network
airnet.edge.df <- data.frame(from = routes$FromNum, to = routes$ToNum)
airnet.edge.df <- airnet.edge.df[complete.cases(airnet.edge.df),]
airnet <- graph.data.frame(airnet.edge.df, directed = T)
graph(airnet)
airnet
airnet <- graph(routes$FromNum, routes$ToNum, directed = T)
airports = read.csv("airports.csv")
routes = read.csv("routes.csv")
# Initial Parameters
time = 50       # Length of Simulation
NCR = 0.3       # Prob of Neighbor Contraction
i.time = 4      # Infectious Length
i.start = 1     # Number of airports starting with pathogen
airnet.edge.df <- data.frame(from = routes$FromNum, to = routes$ToNum)
airnet.edge.df <- airnet.edge.df[complete.cases(airnet.edge.df),]
airnet <- graph(routes$FromNum, routes$ToNum, directed = T)
View(airnet.edge.df)
airports = read.csv("airports.csv")
routes = read.csv("routes.csv")
View(airports)
View(routes)
airnet.edge.df <- data.frame(from = routes[,4], to = routes[,6])
airnet.edge.df <- airnet.edge.df[complete.cases(airnet.edge.df),]
airnet <- graph(airnet.edge.df, directed = T)
View(routes)
View(airnet.edge.df)
View(airnet.edge.df)
airnet <- graph.empty()
nrow(airports)
View(airports)
airports = read.csv("airports.csv", header = F)
View(airports)
View(airports)
View(airports)
airnet <- graph.empty()
airnet <- add.vertices(airnet, nrow(airports),
ID = as.character(airports[,1]),
IATA = as.character(airports[,5]),
NAT = as.character(airports[,4])
)
airnet
V(airnet)$ID
View(routes)
edges <- data.frame(from = routes[,4], to = routes[,6])
airnet <- add.edges(airnet, t(edges))
graph(airnet)
edges <- edges[complete.cases(edges),]
airnet <- add.edges(airnet, t(edges))
airports = read.csv("airports.csv", header = F)
routes = read.csv("routes.csv")
# Initial Parameters -----------------------------------------------------------------
time = 50       # Length of Simulation
NCR = 0.3       # Prob of Neighbor Contraction
i.time = 4      # Infectious Length
i.start = 1     # Number of airports starting with pathogen
# Generate the network ---------------------------------------------------------------
airnet <- graph.empty()
airnet <- add.vertices(airnet, nrow(airports),
ID = as.character(airports[,1]),
IATA = as.character(airports[,5]),
NAT = as.character(airports[,4])
)
#V(airnet)$ID #View the vertices.
edges <- data.frame(from = routes[,4], to = routes[,6])
edges <- edges[complete.cases(edges),]
edges <- edges[complete.cases(edges),]
View(edges)
View(edges)
View(routes)
edges <- edges[complete.cases(edges)]
edges <- edges[complete.cases(edges),]
airnet <- add.edges(airnet, t(edges))
airnet <- add.edges(airnet, t(edges), value = F)
edges <- edges[complete.cases(edges),]
airnet <- add.edges(airnet, edges, value = F)
airnet <- add.edges(airnet, from = routes[,4], to = routes[,6])
airnet <- add.edges(airnet, from = routes[,4], to = routes[,6], value = F)
# Attach Data
main.data = read.csv("airports.csv")
route.data = read.csv("routes.csv")
# Creates second false vector to store true values
na.col <- vector(length = main.data$ID[length(main.data$ID)])
# Makes mixed matrix.
fix.mat <- matrix(c(1:main.data$ID[length(main.data$ID)], na.col), nc = 2)
# Apply true #s to correct ID in string.
for (i in 1:length(main.data$ID)){
fix.mat[main.data$ID[i],2] <- main.data$ID[i]
}
# Make a list of all of the problems, or IDs that are not represented in the data set.
problem.points <- list()
for (i in 1:length(main.data$ID)){
if (fix.mat[i,2] == 0){
problem.points <- c(problem.points, fix.mat[i,1])
}
}
# Matrix for points to remove.
remove <- matrix(problem.points)
route.data <- route.data[complete.cases(route.data),]
for (i in 1:length(route.data$FromNum)){
for (k in 1:length(remove)){
if (route.data$FromNum[i] == remove[k]){
route.data$FromNum[i] <- NA
}
if (route.data$ToNum[i] == remove[k]){
route.data$ToNum[i] <- NA
}
}
}
flight.data <- route.data[complete.cases(route.data),]
write.table(flight.data, file="flight.data.csv",sep=",",row.names=F)
main.data = read.csv("airports.csv")
route.data = read.csv("routes.csv")
View(route.data)
# Read in data files. ----------------------------------------------------------------
airports = read.csv("airports.csv", header = F)
routes = read.csv("routes.csv", header = F)
# Initial Parameters -----------------------------------------------------------------
time = 50       # Length of Simulation
NCR = 0.3       # Prob of Neighbor Contraction
i.time = 4      # Infectious Length
i.start = 1     # Number of airports starting with pathogen
# Generate the network ---------------------------------------------------------------
airnet <- graph.empty()
airnet <- add.vertices(airnet, nrow(airports),
ID = as.character(airports[,1]),
IATA = as.character(airports[,5]),
NAT = as.character(airports[,4])
)
#V(airnet)$ID #View the vertices.
edges <- data.frame(from = routes[,4], to = routes[,6])
airnet <- add.edges(airnet, from = routes[,4], to = routes[,6], value = F)
# Read in data files. ----------------------------------------------------------------
airports = read.csv("airports.csv", header = F)
routes = read.csv("routes.csv", header = F)
# Initial Parameters -----------------------------------------------------------------
time = 50       # Length of Simulation
NCR = 0.3       # Prob of Neighbor Contraction
i.time = 4      # Infectious Length
i.start = 1     # Number of airports starting with pathogen
# Generate the network ---------------------------------------------------------------
airnet <- graph.empty()
airnet <- add.edges(airnet, from = routes[,4], to = routes[,6], value = F)
airnet <- add.edges(airnet, from = routes[,4], to = routes[,6])
edges <- data.frame(from = routes[,4], to = routes[,6])
airnet <- add.edges(airnet, edges)
airnet <- add.edges(airnet, t(edges))
View(airports)
airports$V1[length(airports)]
View(airports)
airports$1[length(airports)]
airports$[length(airports)]
airports$V2[length(airports)]
airports$V2[nrow(airports)]
airports$V1[nrow(airports)]
vertices <- data.frame(ID = 1:airports$V1[nrow(airports)])
View(vertices)
View(airports)
i = 2
i == airports$V1[i]
View(vertices)
View(airports)
View(airports)
View(airports)
for (i in 1:length(vertices)){
if (i == airports$V1[i]){
vertices[i,2] <- airports$V5[i]
vertices[i,3] <- airports$V4[i]
}
}
View(vertices)
length(vertices)
length(vertices$V1)
View(vertices)
length(vertices$ID)
vertices <- data.frame(ID = 1:airports$V1[nrow(airports)])
for (i in 1:length(vertices$ID)){
if (i == airports$V1[i]){
vertices[i,2] <- airports$V5[i]
vertices[i,3] <- airports$V4[i]
}
}
View(vertices)
vertices <- data.frame(ID = 1:airports$V1[nrow(airports)])
for (i in 1:length(vertices$ID)){
if (i == i){
vertices[i,2] <- 0
vertices[i,3] <- 0
}
if (i == airports$V1[i]){
vertices[i,2] <- airports$V5[i]
vertices[i,3] <- airports$V4[i]
}
}
View(vertices)
vertices <- data.frame(ID = 1:airports$V1[nrow(airports)])
for (i in 1:length(vertices$ID)){
if (i == airports$V1[i]){
vertices[i,2] <- airports$V5[i]
vertices[i,3] <- airports$V4[i]
} else {}
}
View(vertices)
vertices <- data.frame(ID = 1:airports$V1[nrow(airports)])
for (i in 1:length(vertices$ID)){
if (i == airports$V1[i]){
vertices[i,2] <- airports$V5[i]
vertices[i,3] <- airports$V4[i]
} else {
vertices[i,2] <- 0
vertices[i,3] <- 0
}
}
