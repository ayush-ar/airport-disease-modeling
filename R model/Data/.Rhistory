}
p0 <- c(S = 0, I = 1, R = 0)	# An initial guess as to the solution
ans <- multiroot(f = rhs, start = p0)
ans
############
############
##
##  Now we use the Jacobian to
##  classify the equilibrium
##
############
############
#	Define the equilibrium point
Sstar = ans$root[1]
Istar = ans$root[2]
Rstar = ans$root[3]
#	Remember:  The solution is stable if and only if every eigenvalue has a negative real part.
##  Sadly, it looks as though we need to retype the system,
##  as the Jacobian evaluator expects something
##  different than the solver..
mod <- function (t = 0, y = c(0,0,0), parms = NULL)
{
beta	= .6 	# contact rate
gamma	= .1	# recovery rate
mu		= 1/365 	# birth rate
S <- y[1]
I <- y[2]
R <- y[3]
r <- numeric()
r[1] <- mu - beta * S * I - mu * S
r[2] <- beta * S * I - gamma * I - mu * I
r[3] <- gamma * I - mu * R
return(r)
}
JJ <- jacobian.full(y = c(Sstar, Istar, Rstar), func = mod)
JJ
eigen(JJ)
#  Using R to find solutions to systems of ODEs and to
#	check those solutions for stability.
#
#	Chris Leary, 10 February 2014
#	WARNING:  The solvers can be glitchy!
#
#  Install the rootSolve package
#	install.packages("rootSolve")
#	Load the rootSolve package
library(rootSolve)
# Clear the variables
rm(list=ls())
# 	Values of the parameters
beta	= .6 	# contact rate
gamma	= .1	# recovery rate
mu		=  1/365 	# birth rate
#	We define the right hand side of the system that we want to solve
rhs <- function(p)	{
beta	= .6 	# contact rate
gamma	= .1	# recovery rate
mu		= 1/365 	# birth rate
S <- p[1]
I <- p[2]
R <- p[3]
r <- numeric()
r[1] <- mu - beta * S * I - mu * S
r[2] <- beta * S * I - gamma * I - mu * I
r[3] <- gamma * I - mu * R
return(r)
}
p0 <- c(S = 0, I = 1, R = 0)	# An initial guess as to the solution
ans <- multiroot(f = rhs, start = p0)
ans
############
############
##
##  Now we use the Jacobian to
##  classify the equilibrium
##
############
############
#	Define the equilibrium point
Sstar = ans$root[1]
Istar = ans$root[2]
Rstar = ans$root[3]
#	Remember:  The solution is stable if and only if every eigenvalue has a negative real part.
##  Sadly, it looks as though we need to retype the system,
##  as the Jacobian evaluator expects something
##  different than the solver..
mod <- function (t = 0, y = c(0,0,0), parms = NULL)
{
beta	= .6 	# contact rate
gamma	= .1	# recovery rate
mu		= 1/365 	# birth rate
S <- y[1]
I <- y[2]
R <- y[3]
r <- numeric()
r[1] <- mu - beta * S * I - mu * S
r[2] <- beta * S * I - gamma * I - mu * I
r[3] <- gamma * I - mu * R
return(r)
}
JJ <- jacobian.full(y = c(Sstar, Istar, Rstar), func = mod)
JJ
eigen(JJ)
Sstar = 1
Istar = 0
Rstar = 0
JJ <- jacobian.full(y = c(Sstar, Istar, Rstar), func = mod)
JJ
eigen(JJ)
## SIR Model
## MBS Spring 2014
## Chris Leary
## Load in the DiffEq solver
## _One time only_, you need to install the package deSolve by running
## the next command:
#  install.packages("deSolve") # Comment this line out after you have executed it once
## One time per session, you need to load the package into R by running this
## next line, but it doesn't hurt to run it often...
library(deSolve)
# Clear the memory
rm(list=ls())
#  First, the parameters for our model:
pars <- c( beta	= .6,  	  # contact rate
gamma	= .1,   # recovery rate
mu = 1/15     # birth/death
)
#	Then, the initial values of each state variable:
init.values <- c(S = 0.15123236, I = 0.04210047, R = 0.80666717)
#	The times we want to see
times <- seq(0, 100000, by = 1)
#	Now we can define the differential equation model:
SIR <- function(time, y.values, parameters) {
with(as.list(c(y.values, parameters)), {
45
dS.dt = - beta * S * I - mu * S + mu
dI.dt = beta * S * I - gamma * I - mu * I
dR.dt = gamma * I - mu * R
return(list(c(dS.dt, dI.dt, dR.dt)))
})
}
#	Having defined everything, now we ask the program ode
#	to actually solve the system:
out <- as.data.frame(ode(func = SIR, y = init.values,
parms = pars, times = times))
#	And now we can make a nice plot of our results:
matplot(out$time, out[ ,2:4], type = "l", xlab = "time",
ylab = "proportion of the population", main = "SIR Model", lwd = 3,
lty = 1, ylim=c(0,1))
legend("right", c("Susceptible", "Infectious", "Removed"),
col = 1:3, lty = 1, lwd = 3)
tail(out)
##
##
##
##
##  Look at R_\infty, the percentage of the population that is infectious during
##  the epidemic.  We can estimate this by finding a root of the equation
##  1 - x - e^(-R0x)
Beta <- as.numeric(pars[1])
Gamma <- as.numeric(pars[2])
R0 <- Beta/Gamma
f <- function(x){
1 - x - exp(-R0 * x)
}
f(1)
uniroot(f, c(.0001,1))  # Finds the root of a single variable function, looking in the given interval
## SIR Model
## MBS Spring 2014
## Chris Leary
## Load in the DiffEq solver
## _One time only_, you need to install the package deSolve by running
## the next command:
#  install.packages("deSolve") # Comment this line out after you have executed it once
## One time per session, you need to load the package into R by running this
## next line, but it doesn't hurt to run it often...
library(deSolve)
# Clear the memory
rm(list=ls())
#  First, the parameters for our model:
pars <- c( beta	= .6,  	  # contact rate
gamma	= .1,   # recovery rate
mu = 1/15     # birth/death
)
#	Then, the initial values of each state variable:
init.values <- c(S = 0.15123236, I = 0.04210047, R = 0.80666717)
#	The times we want to see
times <- seq(0, 1000, by = 1)
#	Now we can define the differential equation model:
SIR <- function(time, y.values, parameters) {
with(as.list(c(y.values, parameters)), {
45
dS.dt = - beta * S * I - mu * S + mu
dI.dt = beta * S * I - gamma * I - mu * I
dR.dt = gamma * I - mu * R
return(list(c(dS.dt, dI.dt, dR.dt)))
})
}
#	Having defined everything, now we ask the program ode
#	to actually solve the system:
out <- as.data.frame(ode(func = SIR, y = init.values,
parms = pars, times = times))
#	And now we can make a nice plot of our results:
matplot(out$time, out[ ,2:4], type = "l", xlab = "time",
ylab = "proportion of the population", main = "SIR Model", lwd = 3,
lty = 1, ylim=c(0,1))
legend("right", c("Susceptible", "Infectious", "Removed"),
col = 1:3, lty = 1, lwd = 3)
tail(out)
##
##
##
##
##  Look at R_\infty, the percentage of the population that is infectious during
##  the epidemic.  We can estimate this by finding a root of the equation
##  1 - x - e^(-R0x)
Beta <- as.numeric(pars[1])
Gamma <- as.numeric(pars[2])
R0 <- Beta/Gamma
f <- function(x){
1 - x - exp(-R0 * x)
}
f(1)
uniroot(f, c(.0001,1))  # Finds the root of a single variable function, looking in the given interval
## SIR Model
## MBS Spring 2014
## Chris Leary
## Load in the DiffEq solver
## _One time only_, you need to install the package deSolve by running
## the next command:
#  install.packages("deSolve") # Comment this line out after you have executed it once
## One time per session, you need to load the package into R by running this
## next line, but it doesn't hurt to run it often...
library(deSolve)
# Clear the memory
rm(list=ls())
#  First, the parameters for our model:
pars <- c( beta	= .6,  	  # contact rate
gamma	= .1,   # recovery rate
mu = 1/15     # birth/death
)
#	Then, the initial values of each state variable:
init.values <- c(S = 0.15123236, I = 0.04210047, R = 0.80666717)
#	The times we want to see
times <- seq(0, 100, by = 1)
#	Now we can define the differential equation model:
SIR <- function(time, y.values, parameters) {
with(as.list(c(y.values, parameters)), {
45
dS.dt = - beta * S * I - mu * S + mu
dI.dt = beta * S * I - gamma * I - mu * I
dR.dt = gamma * I - mu * R
return(list(c(dS.dt, dI.dt, dR.dt)))
})
}
#	Having defined everything, now we ask the program ode
#	to actually solve the system:
out <- as.data.frame(ode(func = SIR, y = init.values,
parms = pars, times = times))
#	And now we can make a nice plot of our results:
matplot(out$time, out[ ,2:4], type = "l", xlab = "time",
ylab = "proportion of the population", main = "SIR Model", lwd = 3,
lty = 1, ylim=c(0,1))
legend("right", c("Susceptible", "Infectious", "Removed"),
col = 1:3, lty = 1, lwd = 3)
tail(out)
##
##
##
##
##  Look at R_\infty, the percentage of the population that is infectious during
##  the epidemic.  We can estimate this by finding a root of the equation
##  1 - x - e^(-R0x)
Beta <- as.numeric(pars[1])
Gamma <- as.numeric(pars[2])
R0 <- Beta/Gamma
f <- function(x){
1 - x - exp(-R0 * x)
}
f(1)
uniroot(f, c(.0001,1))  # Finds the root of a single variable function, looking in the given interval
## SIR Model
## MBS Spring 2014
## Chris Leary
## Load in the DiffEq solver
## _One time only_, you need to install the package deSolve by running
## the next command:
#  install.packages("deSolve") # Comment this line out after you have executed it once
## One time per session, you need to load the package into R by running this
## next line, but it doesn't hurt to run it often...
library(deSolve)
# Clear the memory
rm(list=ls())
#  First, the parameters for our model:
pars <- c( beta	= .6,  	  # contact rate
gamma	= .1,   # recovery rate
mu = 1/1000     # birth/death
)
#	Then, the initial values of each state variable:
init.values <- c(S = 0.15123236, I = 0.04210047, R = 0.80666717)
#	The times we want to see
times <- seq(0, 100, by = 1)
#	Now we can define the differential equation model:
SIR <- function(time, y.values, parameters) {
with(as.list(c(y.values, parameters)), {
45
dS.dt = - beta * S * I - mu * S + mu
dI.dt = beta * S * I - gamma * I - mu * I
dR.dt = gamma * I - mu * R
return(list(c(dS.dt, dI.dt, dR.dt)))
})
}
#	Having defined everything, now we ask the program ode
#	to actually solve the system:
out <- as.data.frame(ode(func = SIR, y = init.values,
parms = pars, times = times))
#	And now we can make a nice plot of our results:
matplot(out$time, out[ ,2:4], type = "l", xlab = "time",
ylab = "proportion of the population", main = "SIR Model", lwd = 3,
lty = 1, ylim=c(0,1))
legend("right", c("Susceptible", "Infectious", "Removed"),
col = 1:3, lty = 1, lwd = 3)
tail(out)
##
##
##
##
##  Look at R_\infty, the percentage of the population that is infectious during
##  the epidemic.  We can estimate this by finding a root of the equation
##  1 - x - e^(-R0x)
Beta <- as.numeric(pars[1])
Gamma <- as.numeric(pars[2])
R0 <- Beta/Gamma
f <- function(x){
1 - x - exp(-R0 * x)
}
f(1)
uniroot(f, c(.0001,1))  # Finds the root of a single variable function, looking in the given interval
## SIR Model
## MBS Spring 2014
## Chris Leary
## Load in the DiffEq solver
## _One time only_, you need to install the package deSolve by running
## the next command:
#  install.packages("deSolve") # Comment this line out after you have executed it once
## One time per session, you need to load the package into R by running this
## next line, but it doesn't hurt to run it often...
library(deSolve)
# Clear the memory
rm(list=ls())
#  First, the parameters for our model:
pars <- c( beta	= .6,  	  # contact rate
gamma	= .1,   # recovery rate
mu = 1/365     # birth/death
)
#	Then, the initial values of each state variable:
init.values <- c(S = 0.15123236, I = 0.04210047, R = 0.80666717)
#	The times we want to see
times <- seq(0, 100, by = 1)
#	Now we can define the differential equation model:
SIR <- function(time, y.values, parameters) {
with(as.list(c(y.values, parameters)), {
45
dS.dt = - beta * S * I - mu * S + mu
dI.dt = beta * S * I - gamma * I - mu * I
dR.dt = gamma * I - mu * R
return(list(c(dS.dt, dI.dt, dR.dt)))
})
}
#	Having defined everything, now we ask the program ode
#	to actually solve the system:
out <- as.data.frame(ode(func = SIR, y = init.values,
parms = pars, times = times))
#	And now we can make a nice plot of our results:
matplot(out$time, out[ ,2:4], type = "l", xlab = "time",
ylab = "proportion of the population", main = "SIR Model", lwd = 3,
lty = 1, ylim=c(0,1))
legend("right", c("Susceptible", "Infectious", "Removed"),
col = 1:3, lty = 1, lwd = 3)
tail(out)
##
##
##
##
##  Look at R_\infty, the percentage of the population that is infectious during
##  the epidemic.  We can estimate this by finding a root of the equation
##  1 - x - e^(-R0x)
Beta <- as.numeric(pars[1])
Gamma <- as.numeric(pars[2])
R0 <- Beta/Gamma
f <- function(x){
1 - x - exp(-R0 * x)
}
f(1)
uniroot(f, c(.0001,1))  # Finds the root of a single variable function, looking in the given interval
## SIR Model
## MBS Spring 2014
## Chris Leary
## Load in the DiffEq solver
## _One time only_, you need to install the package deSolve by running
## the next command:
#  install.packages("deSolve") # Comment this line out after you have executed it once
## One time per session, you need to load the package into R by running this
## next line, but it doesn't hurt to run it often...
library(deSolve)
# Clear the memory
rm(list=ls())
#  First, the parameters for our model:
pars <- c( beta	= .6,  	  # contact rate
gamma	= .1,   # recovery rate
mu = 1/365     # birth/death
)
#	Then, the initial values of each state variable:
init.values <- c(S = 0.15123236, I = 0.04210047, R = 0.80666717)
#	The times we want to see
times <- seq(0, 100, by = 1)
#	Now we can define the differential equation model:
SIR <- function(time, y.values, parameters) {
with(as.list(c(y.values, parameters)), {
45
dS.dt = - beta * S * I - mu * S + mu
dI.dt = beta * S * I - gamma * I - mu * I
dR.dt = gamma * I - mu * R
return(list(c(dS.dt, dI.dt, dR.dt)))
})
}
#	Having defined everything, now we ask the program ode
#	to actually solve the system:
out <- as.data.frame(ode(func = SIR, y = init.values,
parms = pars, times = times))
#	And now we can make a nice plot of our results:
matplot(out$time, out[ ,2:4], type = "l", xlab = "time",
ylab = "proportion of the population", main = "SIR Model", lwd = 3,
lty = 1, ylim=c(0,1))
legend("right", c("Susceptible", "Infectious", "Removed"),
col = 1:3, lty = 1, lwd = 3)
tail(out)
##
##
##
##
##  Look at R_\infty, the percentage of the population that is infectious during
##  the epidemic.  We can estimate this by finding a root of the equation
##  1 - x - e^(-R0x)
Beta <- as.numeric(pars[1])
Gamma <- as.numeric(pars[2])
R0 <- Beta/Gamma
f <- function(x){
1 - x - exp(-R0 * x)
}
f(1)
uniroot(f, c(.0001,1))  # Finds the root of a single variable function, looking in the given interval
## SIR Model
## MBS Spring 2014
## Chris Leary
## Load in the DiffEq solver
## _One time only_, you need to install the package deSolve by running
## the next command:
#  install.packages("deSolve") # Comment this line out after you have executed it once
## One time per session, you need to load the package into R by running this
## next line, but it doesn't hurt to run it often...
library(deSolve)
# Clear the memory
rm(list=ls())
#  First, the parameters for our model:
pars <- c( beta	= .6,  	  # contact rate
gamma	= .1,   # recovery rate
mu = 1/365     # birth/death
)
#	Then, the initial values of each state variable:
init.values <- c(S = 0.15123236, I = 0.04210047, R = 0.80666717)
#	The times we want to see
times <- seq(0, 1000, by = 1)
#	Now we can define the differential equation model:
SIR <- function(time, y.values, parameters) {
with(as.list(c(y.values, parameters)), {
45
dS.dt = - beta * S * I - mu * S + mu
dI.dt = beta * S * I - gamma * I - mu * I
dR.dt = gamma * I - mu * R
return(list(c(dS.dt, dI.dt, dR.dt)))
})
}
#	Having defined everything, now we ask the program ode
#	to actually solve the system:
out <- as.data.frame(ode(func = SIR, y = init.values,
parms = pars, times = times))
#	And now we can make a nice plot of our results:
matplot(out$time, out[ ,2:4], type = "l", xlab = "time",
ylab = "proportion of the population", main = "SIR Model", lwd = 3,
lty = 1, ylim=c(0,1))
legend("right", c("Susceptible", "Infectious", "Removed"),
col = 1:3, lty = 1, lwd = 3)
tail(out)
##
##
##
##
##  Look at R_\infty, the percentage of the population that is infectious during
##  the epidemic.  We can estimate this by finding a root of the equation
##  1 - x - e^(-R0x)
Beta <- as.numeric(pars[1])
Gamma <- as.numeric(pars[2])
R0 <- Beta/Gamma
f <- function(x){
1 - x - exp(-R0 * x)
}
f(1)
uniroot(f, c(.0001,1))  # Finds the root of a single variable function, looking in the given interval
setwd("~/Documents/Uni/Research/airport_flu_modeling/R model/Data")
library(igraph)
main.data = read.csv("airports.csv")
route.data = read.csv("routes.csv")
