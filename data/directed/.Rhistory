r <- numeric()
r[1] <- N - alpha*N*P
r[2] <- beta*N*P - zeta*P
return(r)
}
ans <- multiroot(f = comp, start = z0)
Nstar = ans$root[1]
Pstar = ans$root[2]
compJ = function (t = 0, y = c(0,0), parms = NULL){
alpha = 1/4
beta = 1/2
zeta = 1/3
N <- y[1]
P <- y[2]
r <- numeric()
r[1] <- N - alpha*N*P
r[2] <- beta*N*P - zeta*P
return(r)
}
jacobian = jacobian.full(y = c(Nstar, Pstar), func = compJ)
eigen(jacobian)
Ninit = 10 # the initial population sizentimes = 200 # number of time stepsK = 100 # the carrying capacityr = 0.25 # growth rate parameterN = Ninit # set initial population sizefor (i in 2:ntimes) {  N[i] = N[i-1] + r*N[i-1]*(1 - N[i-1]/K)}plot(N, pch = 16,ylim = c(0,120), xlab = "Time Step", cex.lab = 1.5, cex = 0.5)
Ninit = 10 # the initial population size
ntimes = 200 # number of time steps
K = 100 # the carrying capacity
r = 0.25 # growth rate parameter
N = Ninit # set initial population size
for (i in 2:ntimes) {
N[i] = N[i-1] + r*N[i-1]*(1 - N[i-1]/K)
}
plot(N, pch = 16,ylim = c(0,120), xlab = "Time Step", cex.lab = 1.5, cex = 0.5)
K = rnorm(1,mean=100,sd=10) # get one value, mean = 100, sd = 10
Ninit = 10 # the initial population sizentimes = 200 # number of time stepsK = 100 # the carrying capacityr = 0.25 # growth rate parameterN = Ninit # set initial population sizefor (i in 2:ntimes) {  N[i] = N[i-1] + r*N[i-1]*(1 - N[i-1]/K)}plot(N, pch = 16,ylim = c(0,120), xlab = "Time Step", cex.lab = 1.5, cex = 0.5)K = rnorm(1,mean=100,sd=10) # get one value, mean = 100, sd = 10for (i in 2:ntimes) {  N[i] = N[i-1] + r*N[i-1]*(1 - N[i-1]/K[i])}for (h = 1:nreps) {  N = Ninit # set initial population size  for (i in 2:ntimes) {    K = rnorm(1, mean = Kmean,sd = Ksd) # make K    N[i] = N[i-1] + r*N[i-1]*(1 - N[i-1]/K)  }  last.value[h] = N[ntimes] # ntimes gives the last pop value}
Ninit = 10 # the initial population sizentimes = 200 # number of time stepsK = 100 # the carrying capacityr = 0.25 # growth rate parameterN = Ninit # set initial population sizefor (i in 2:ntimes) {  N[i] = N[i-1] + r*N[i-1]*(1 - N[i-1]/K)}plot(N, pch = 16,ylim = c(0,120), xlab = "Time Step", cex.lab = 1.5, cex = 0.5)K = rnorm(1,mean=100,sd=10) # get one value, mean = 100, sd = 10for (i in 2:ntimes) {  N[i] = N[i-1] + r*N[i-1]*(1 - N[i-1]/K[i])}for (h = 1:nreps) {  N = Ninit # set initial population size  for (i in 2:ntimes) {    K = rnorm(1, mean = Kmean,sd = Ksd) # make K    N[i] = N[i-1] + r*N[i-1]*(1 - N[i-1]/K)  }  last.value[h] = N[ntimes] # ntimes gives the last pop value}
Ninit = 10ntimes = 200K = 100r = 0.25N = Ninitfor (i in 2:ntimes) {  N[i] = N[i-1] + r*N[i-1]*(1 - N[i-1]/K)}plot(N, pch = 16,ylim = c(0,120), xlab = "Time Step", cex.lab = 1.5, cex = 0.5)K = rnorm(1,mean=100,sd=10) # get one value, mean = 100, sd = 10for (i in 2:ntimes) {  N[i] = N[i-1] + r*N[i-1]*(1 - N[i-1]/K[i])}for (h = 1:nreps) {  N = Ninit # set initial population size  for (i in 2:ntimes) {    K = rnorm(1, mean = Kmean,sd = Ksd) # make K    N[i] = N[i-1] + r*N[i-1]*(1 - N[i-1]/K)  }  last.value[h] = N[ntimes] # ntimes gives the last pop value}
Ninit = 10
ntimes = 200
K = 100
r = 0.25
N = Ninit
Ninit = 10 # the initial population size
ntimes = 200 # number of time steps
K = 100 # the carrying capacity
r = 0.25 # growth rate parameter
N = Ninit # set initial population size
for (i in 2:ntimes) {
N[i] = N[i-1] + r*N[i-1]*(1 - N[i-1]/K)
}
plot(N, pch = 16,ylim = c(0,120), xlab = "Time Step", cex.lab = 1.5, cex = 0.5)
K = rnorm(1,mean=100,sd=10) # get one value, mean = 100, sd = 10
for (i in 2:ntimes) {
N[i] = N[i-1] + r*N[i-1]*(1 - N[i-1]/K[i])
}
for (h = 1:nreps) {
nreps = 10
for (h = 1:nreps) {
nreps = 10
for (h in 1:nreps) {
N = Ninit # set initial population size
for (i in 2:ntimes) {
K = rnorm(1, mean = Kmean,sd = Ksd) # make K
N[i] = N[i-1] + r*N[i-1]*(1 - N[i-1]/K)
}
last.value[h] = N[ntimes] # ntimes gives the last pop value
library(deSolve)
pars <- c(
beta.HH = 10,
beta.LL = 1,
beta.HL = 0.1,
beta.LH = 0.1,
gamma = 1,
)
init.values <- c(SH = 0.49, IH = 0.01, SL = 0.49, IL = 0.01)
times <- seq(0, 100, by = 1)
SIR <- function(time, y.values, parameters) {
with(as.list(c(y.values, parameters)), {
dSH.dt = gamma*IH - beta.HH*SH*IH - beta.LH*SH*IL
dSL.dt = gamma*IL - beta.LL*SL*IL - beta.HL*SL*IH
dIH.dt = -gamma*IH + beta.HH*SH*IH + beta.LH*SH*IL
dIL.dt = -gamma*IL + beta.LL*SL*IL + beta.HL*SL*IH
return(list(c(dSH.dt, dIH.dt, dSL.dt, dIL.dt)))
})
}
SISI <- function(time, y.values, parameters) {
with(as.list(c(y.values, parameters)), {
dSH.dt = gamma*IH - beta.HH*SH*IH - beta.LH*SH*IL
dSL.dt = gamma*IL - beta.LL*SL*IL - beta.HL*SL*IH
dIH.dt = -gamma*IH + beta.HH*SH*IH + beta.LH*SH*IL
dIL.dt = -gamma*IL + beta.LL*SL*IL + beta.HL*SL*IH
return(list(c(dSH.dt, dIH.dt, dSL.dt, dIL.dt)))
})
}
out <- as.data.frame(ode(func = SISI, y = init.values,
parms = pars, times = times))
SISI <- function(time, y.values, parameters) {
with(as.list(c(y.values, parameters)), {
dSH.dt = gamma*IH - beta.HH*SH*IH - beta.LH*SH*IL
dSL.dt = gamma*IL - beta.LL*SL*IL - beta.HL*SL*IH
dIH.dt = -gamma*IH + beta.HH*SH*IH + beta.LH*SH*IL
dIL.dt = -gamma*IL + beta.LL*SL*IL + beta.HL*SL*IH
return(list(c(dSH.dt, dIH.dt, dSL.dt, dIL.dt)))
})
}
pars <- c(
beta.HH = 10,
beta.LL = 1,
beta.HL = 0.1,
beta.LH = 0.1,
gamma = 1,
)
init.values <- c(SH = 0.49, IH = 0.01, SL = 0.49, IL = 0.01)
times <- seq(0, 100, by = 1)
SISI <- function(time, y.values, parameters) {
with(as.list(c(y.values, parameters)), {
dSH.dt = gamma*IH - beta.HH*SH*IH - beta.LH*SH*IL
dSL.dt = gamma*IL - beta.LL*SL*IL - beta.HL*SL*IH
dIH.dt = -gamma*IH + beta.HH*SH*IH + beta.LH*SH*IL
dIL.dt = -gamma*IL + beta.LL*SL*IL + beta.HL*SL*IH
return(list(c(dSH.dt, dIH.dt, dSL.dt, dIL.dt)))
})
}
pars <- c(
beta.HH = 10,
beta.LL = 1,
beta.HL = 0.1,
beta.LH = 0.1,
gamma = 1
)
out <- as.data.frame(ode(func = SISI, y = init.values,
parms = par, times = times))
times <- seq(1, 100, by = 1)
out <- as.data.frame(ode(func = SISI, y = init.values,
parms = par, times = times))
# SISI Model
library(deSolve)
pars <- c(
beta.HH = 10,
beta.LL = 1,
beta.HL = 0.1,
beta.LH = 0.1,
gam = 1
)
init.values <- c(SH = 0.49, IH = 0.01, SL = 0.49, IL = 0.01)
times <- seq(1, 100, by = 1)
SISI <- function(time, y.values, parameters) {
with(as.list(c(y.values, parameters)), {
dSH.dt = gam*IH - beta.HH*SH*IH - beta.LH*SH*IL
dSL.dt = gam*IL - beta.LL*SL*IL - beta.HL*SL*IH
dIH.dt = -gam*IH + beta.HH*SH*IH + beta.LH*SH*IL
dIL.dt = -gam*IL + beta.LL*SL*IL + beta.HL*SL*IH
return(list(c(dSH.dt, dIH.dt, dSL.dt, dIL.dt)))
})
}
out <- as.data.frame(ode(func = SISI, y = init.values,
parms = par, times = times))
out <- as.data.frame(ode(func = SISI, y = init.values,
parms = pars, times = times))
View(out)
View(out)
matplot(out$time, out[ ,2:5], type = "l", xlab = "time",
ylab = "Proportion of the Population", main = "Black Death Model", lwd = 2,
lty = 1, xlim = c(0,100))
legend("right", c("SH", "IH", "SL", "LL"),
col = 1:4, lty = 1, lwd = 3)
matplot(out$time, out[ ,2:5], type = "l", xlab = "time",
ylab = "Proportion of the Population", main = "Black Death Model", lwd = 2,
lty = 1, xlim = c(0,10))
legend("right", c("SH", "IH", "SL", "LL"),
col = 1:4, lty = 1, lwd = 3)
# SISI Model
library(deSolve)
pars <- c(
beta.HH = 10,
beta.LL = 1,
beta.HL = 0.1,
beta.LH = 0.1,
gam = 1
)
init.values <- c(SH = 0.2, IH = 0, SL = 0.79, IL = 0.01)
times <- seq(1, 100, by = 1)
SISI <- function(time, y.values, parameters) {
with(as.list(c(y.values, parameters)), {
dSH.dt = gam*IH - beta.HH*SH*IH - beta.LH*SH*IL
dSL.dt = gam*IL - beta.LL*SL*IL - beta.HL*SL*IH
dIH.dt = -gam*IH + beta.HH*SH*IH + beta.LH*SH*IL
dIL.dt = -gam*IL + beta.LL*SL*IL + beta.HL*SL*IH
return(list(c(dSH.dt, dIH.dt, dSL.dt, dIL.dt)))
})
}
out <- as.data.frame(ode(func = SISI, y = init.values,
parms = pars, times = times))
matplot(out$time, out[ ,2:5], type = "l", xlab = "time",
ylab = "Proportion of the Population", main = "Black Death Model", lwd = 2,
lty = 1, xlim = c(0,50))
legend("right", c("SH", "IH", "SL", "LL"),
col = 1:4, lty = 1, lwd = 3)
View(out)
out.L <- data.frame(out$time, ln(out[,3]), ln(out[,5]))
out.L <- data.frame(out$time, log(out[,3]), log(out[,5]))
View(out.L)
matplot(out.L[,1], out[ ,2:3], type = "l", xlab = "time",
ylab = "ln Proportion of the Population", lwd = 2,
lty = 1, xlim = c(0,30))
legend("right", c("Infectious High", "Infectious Low"),
col = 1:2, lty = 1, lwd = 3)
legend("bottomright", c("Infectious High", "Infectious Low"),
col = 1:2, lty = 1, lwd = 3)
matplot(out.L[,1], out[ ,2:3], type = "l", xlab = "time",
ylab = "ln Proportion of the Population", lwd = 2,
lty = 1, xlim = c(0,30))
legend("bottomright", c("Infectious High", "Infectious Low"),
col = 1:2, lty = 1, lwd = 3)
# SISI Model
library(deSolve)
pars <- c(
beta.HH = 10,
beta.LL = 1,
beta.HL = 0.1,
beta.LH = 0.1,
gam = 1
)
init.values <- c(SH = 0.2, IH = 0, SL = 0.79, IL = 0.01)
times <- seq(1, 100, by = 1)
SISI <- function(time, y.values, parameters) {
with(as.list(c(y.values, parameters)), {
dSH.dt = gam*IH - beta.HH*SH*IH - beta.LH*SH*IL
dSL.dt = gam*IL - beta.LL*SL*IL - beta.HL*SL*IH
dIH.dt = -gam*IH + beta.HH*SH*IH + beta.LH*SH*IL
dIL.dt = -gam*IL + beta.LL*SL*IL + beta.HL*SL*IH
return(list(c(dSH.dt, dIH.dt, dSL.dt, dIL.dt)))
})
}
out <- as.data.frame(lsoda(func = SISI, y = init.values,
parms = pars, times = times))
matplot(out$time, out[ ,2:5], type = "l", xlab = "time",
ylab = "Proportion of the Population", lwd = 2,
lty = 1, xlim = c(0,50))
legend("right", c("SH", "IH", "SL", "LL"),
col = 1:4, lty = 1, lwd = 3)
# To get Leary's Graph
out.L <- data.frame(out$time, log(out[,3]), log(out[,5]))
matplot(out.L[,1], out[ ,2:3], type = "l", xlab = "time",
ylab = "ln Proportion of the Population", lwd = 2,
lty = 1, xlim = c(0,30))
legend("bottomright", c("Infectious High", "Infectious Low"),
col = 1:2, lty = 1, lwd = 3)
# SISI Model
library(deSolve)
pars <- c(
beta.HH = 10,
beta.LL = 1,
beta.HL = 0.1,
beta.LH = 0.1,
gam = 1
)
init.values <- c(SH = 0.2, IH = 0, SL = 0.7, IL = 0.1)
times <- seq(1, 100, by = 1)
SISI <- function(time, y.values, parameters) {
with(as.list(c(y.values, parameters)), {
dSH.dt = gam*IH - beta.HH*SH*IH - beta.LH*SH*IL
dSL.dt = gam*IL - beta.LL*SL*IL - beta.HL*SL*IH
dIH.dt = -gam*IH + beta.HH*SH*IH + beta.LH*SH*IL
dIL.dt = -gam*IL + beta.LL*SL*IL + beta.HL*SL*IH
return(list(c(dSH.dt, dIH.dt, dSL.dt, dIL.dt)))
})
}
out <- as.data.frame(lsoda(func = SISI, y = init.values,
parms = pars, times = times))
matplot(out$time, out[ ,2:5], type = "l", xlab = "time",
ylab = "Proportion of the Population", lwd = 2,
lty = 1, xlim = c(0,50))
legend("right", c("SH", "IH", "SL", "LL"),
col = 1:4, lty = 1, lwd = 3)
# To get Leary's Graph
out.L <- data.frame(out$time, log(out[,3]), log(out[,5]))
matplot(out.L[,1], out[ ,2:3], type = "l", xlab = "time",
ylab = "ln Proportion of the Population", lwd = 2,
lty = 1, xlim = c(0,30))
legend("bottomright", c("Infectious High", "Infectious Low"),
col = 1:2, lty = 1, lwd = 3)
# SISI Model
library(deSolve)
pars <- c(
beta.HH = 10,
beta.LL = 1,
beta.HL = 0.1,
beta.LH = 0.1,
gam = 1
)
init.values <- c(SH = 0.2, IH = 0, SL = 0.7, IL = 0.1)
times <- seq(1, 100, by = 1)
SISI <- function(time, y.values, parameters) {
with(as.list(c(y.values, parameters)), {
dIH.dt = -gam*IH + beta.HH*SH*IH + beta.LH*SH*IL
dIL.dt = -gam*IL + beta.LL*SL*IL + beta.HL*SL*IH
dSH.dt = gam*IH - beta.HH*SH*IH - beta.LH*SH*IL
dSL.dt = gam*IL - beta.LL*SL*IL - beta.HL*SL*IH
return(list(c(dSH.dt, dIH.dt, dSL.dt, dIL.dt)))
})
}
out <- as.data.frame(lsoda(func = SISI, y = init.values,
parms = pars, times = times))
matplot(out$time, out[ ,2:5], type = "l", xlab = "time",
ylab = "Proportion of the Population", lwd = 2,
lty = 1, xlim = c(0,50))
legend("right", c("SH", "IH", "SL", "IL"),
col = 1:4, lty = 1, lwd = 3)
# To get Leary's Graph
out.L <- data.frame(out$time, log(out[,3]), log(out[,5]))
matplot(out.L[,1], out[ ,2:3], type = "l", xlab = "time",
ylab = "ln Proportion of the Population", lwd = 2,
lty = 1, xlim = c(0,30))
legend("bottomright", c("Infectious High", "Infectious Low"),
col = 1:2, lty = 1, lwd = 3)
# Find the Equilibrium
out[100,5]
View(out)
View(out.L)
matplot(out.L[,1], 1-out[ ,2:3], type = "l", xlab = "time",
ylab = "ln Proportion of the Population", lwd = 2,
lty = 1, xlim = c(0,30))
legend("bottomright", c("Infectious High", "Infectious Low"),
col = 1:2, lty = 1, lwd = 3)
matplot(out.L[,1], -out[ ,2:3], type = "l", xlab = "time",
ylab = "ln Proportion of the Population", lwd = 2,
lty = 1, xlim = c(0,30))
legend("bottomright", c("Infectious High", "Infectious Low"),
col = 1:2, lty = 1, lwd = 3)
# SISI Model
library(deSolve)
pars <- c(
beta.HH = 10,
beta.LL = 1,
beta.HL = 0.1,
beta.LH = 0.1,
gam = 1
)
init.values <- c(SH = 0.2, IH = 0, SL = 0.79999999, IL = 0.00000001)
times <- seq(1, 100, by = 1)
SISI <- function(time, y.values, parameters) {
with(as.list(c(y.values, parameters)), {
dSH.dt = gam*IH - beta.HH*SH*IH - beta.LH*SH*IL
dSL.dt = gam*IL - beta.LL*SL*IL - beta.HL*SL*IH
dIH.dt = -gam*IH + beta.HH*SH*IH + beta.LH*SH*IL
dIL.dt = -gam*IL + beta.LL*SL*IL + beta.HL*SL*IH
return(list(c(dSH.dt, dIH.dt, dSL.dt, dIL.dt)))
})
}
out <- as.data.frame(lsoda(func = SISI, y = init.values,
parms = pars, times = times))
matplot(out$time, out[ ,2:5], type = "l", xlab = "time",
ylab = "Proportion of the Population", lwd = 2,
lty = 1, xlim = c(0,50))
legend("right", c("SH", "IH", "SL", "IL"),
col = 1:4, lty = 1, lwd = 3)
# To get Leary's Graph
out.L <- data.frame(out$time, log(out[,3]), log(out[,5]))
matplot(out.L[,1], out[ ,2:3], type = "l", xlab = "time",
ylab = "ln Proportion of the Population", lwd = 2,
lty = 1, xlim = c(0,30))
legend("bottomright", c("Infectious High", "Infectious Low"),
col = 1:2, lty = 1, lwd = 3)
# Find the Equilibrium
setwd("~/Documents/Uni/Research/airport_flu_modeling/data/directed")
library(plotrix)
library(agricolae)
#library(scatterplot3d)
#library(scales)
R <- as.data.frame(read.csv("random.matrix",header=F))
D <- as.data.frame(read.csv("degree.matrix",header=F))
B <- as.data.frame(read.csv("betweenness.matrix",header=F))
r <- data.frame()
k = 1
for (i in c(1,2,3,4,5)) {
for (j in 1:50) {
r[k,1] <- "random"
r[k,2] <- as.character((i-1)*5)
r[k,3] <- R[j,i]
k = k + 1
}
}
for (i in c(1,2,3,4,5)) {
for (j in 1:50) {
r[k,1] <- "degree"
r[k,2] <- as.character((i-1)*5)
r[k,3] <- D[j,i]
k = k + 1
}
}
for (i in c(1,2,3,4,5)) {
for (j in 1:50) {
r[k,1] <- "betweenness"
r[k,2] <- as.character((i-1)*5)
r[k,3] <- B[j,i]
k = k + 1
}
}
# Log Data of Max Infected and Examine Distrobution
r.random <- data.frame(r[1:250,1],r[1:250,2],log(r[1:250,3]))
r.degree <- data.frame(r[251:500,1],r[251:500,2],log(r[251:500,3]))
r.betweenness <- data.frame(r[501:750,1],r[501:750,2],log(r[501:750,3]))
library(scatterplot3d)
library(scales)
plot(as.numeric(r.random[,2]), as.numeric(r.random[,3]), pch = 16, color = alpha("black", 0.5),
xlab = "Quarantine Effort (%)", ylab = "Log of Total Infected", axes = F, ylim = c(0,10)
)
box()
axis(1, at = 1:5, lab = c("0","5","10","15","20"))
axis(2, at = 0:10 by = 1)
points(as.numeric(r.degree[,2]), as.numeric(r.degree[,3]), pch = 16, col = alpha("red", 0.5))
points(as.numeric(r.betweenness[,2]), as.numeric(r.betweenness[,3]), pch = 16, col = alpha("blue", 0.5))
axis(2, at = 0:10 by = 1)
axis(2, at = 0:10)
par(mfrow=c(2,1))
pars(mfrow=c(2,1))
par(mfrow = c(2,1))
plot(as.numeric(r.random[,2]), as.numeric(r.random[,3]), pch = 16, color = alpha("black", 0.5),
xlab = "Quarantine Effort (%)", ylab = "Log of Total Infected", axes = F, ylim = c(0,10),
main = "Log Transformation"
)
box()
axis(1, at = 1:5, lab = c("0","5","10","15","20"))
axis(2, at = 0:10)
points(as.numeric(r.degree[,2]), as.numeric(r.degree[,3]), pch = 16, col = alpha("red", 0.5))
points(as.numeric(r.betweenness[,2]), as.numeric(r.betweenness[,3]), pch = 16, col = alpha("blue", 0.5))
par(mfrow = c(1,1))
plot(as.numeric(r.random[,2]), as.numeric(r.random[,3]), pch = 16, color = alpha("black", 0.5),
xlab = "Quarantine Effort (%)", ylab = "Log of Total Infected", axes = F, ylim = c(0,10),
main = "Log Transformation"
)
box()
axis(1, at = 1:5, lab = c("0","5","10","15","20"))
axis(2, at = 0:10)
points(as.numeric(r.degree[,2]), as.numeric(r.degree[,3]), pch = 16, col = alpha("red", 0.5))
points(as.numeric(r.betweenness[,2]), as.numeric(r.betweenness[,3]), pch = 16, col = alpha("blue", 0.5))
r.random <- data.frame(r[1:250,1],r[1:250,2],sqrt(r[1:250,3]))
r.degree <- data.frame(r[251:500,1],r[251:500,2],sqrt(r[251:500,3]))
r.betweenness <- data.frame(r[501:750,1],r[501:750,2],sqrt(r[501:750,3]))
plot(as.numeric(r.random[,2]), as.numeric(r.random[,3]), pch = 16, color = alpha("black", 0.5),
xlab = "Quarantine Effort (%)", ylab = "Sqrt of Total Infected", axes = F, ylim = c(0,10),
main = "Sqrt Transformation"
)
box()
axis(1, at = 1:5, lab = c("0","5","10","15","20"))
axis(2, at = 0:10)
points(as.numeric(r.degree[,2]), as.numeric(r.degree[,3]), pch = 16, col = alpha("red", 0.5))
points(as.numeric(r.betweenness[,2]), as.numeric(r.betweenness[,3]), pch = 16, col = alpha("blue", 0.5))
View(r.betweenness)
plot(as.numeric(r.random[,2]), as.numeric(r.random[,3]), pch = 16, color = alpha("black", 0.5),
xlab = "Quarantine Effort (%)", ylab = "Sqrt of Total Infected", axes = F, ylim = c(0,60),
main = "Sqrt Transformation"
)
box()
axis(1, at = 1:5, lab = c("0","5","10","15","20"))
axis(2, at = 0:10)
points(as.numeric(r.degree[,2]), as.numeric(r.degree[,3]), pch = 16, col = alpha("red", 0.5))
points(as.numeric(r.betweenness[,2]), as.numeric(r.betweenness[,3]), pch = 16, col = alpha("blue", 0.5))
plot(as.numeric(r.random[,2]), as.numeric(r.random[,3]), pch = 16, color = alpha("black", 0.5),
xlab = "Quarantine Effort (%)", ylab = "Sqrt of Total Infected", axes = F, ylim = c(0,60),
main = "Sqrt Transformation"
)
box()
axis(1, at = 1:5, lab = c("0","5","10","15","20"))
axis(2, at = 0:60)
points(as.numeric(r.degree[,2]), as.numeric(r.degree[,3]), pch = 16, col = alpha("red", 0.5))
points(as.numeric(r.betweenness[,2]), as.numeric(r.betweenness[,3]), pch = 16, col = alpha("blue", 0.5))
View(r.betweenness)
View(r.random)
r.random <- data.frame(r[1:250,1],r[1:250,2],log(r[1:250,3]))
r.degree <- data.frame(r[251:500,1],r[251:500,2],log(r[251:500,3]))
r.betweenness <- data.frame(r[501:750,1],r[501:750,2],log(r[501:750,3]))
plot(as.numeric(r.random[,2]), as.numeric(r.random[,3]), pch = 16, color = alpha("black", 0.5),
xlab = "Quarantine Effort (%)", ylab = "Sqrt of Total Infected", axes = F, ylim = c(0,60),
main = "Sqrt Transformation"
)
box()
axis(1, at = 1:5, lab = c("0","5","10","15","20"))
axis(2, at = 0:60)
points(as.numeric(r.degree[,2]), as.numeric(r.degree[,3]), pch = 16, col = alpha("red", 0.5))
points(as.numeric(r.betweenness[,2]), as.numeric(r.betweenness[,3]), pch = 16, col = alpha("blue", 0.5))
plot(as.numeric(r.random[,2]), as.numeric(r.random[,3]), pch = 16, color = alpha("black", 0.5),
xlab = "Quarantine Effort (%)", ylab = "Sqrt of Total Infected", axes = F, ylim = c(0,10),
main = "Sqrt Transformation"
)
box()
axis(1, at = 1:5, lab = c("0","5","10","15","20"))
axis(2, at = 0:10)
points(as.numeric(r.degree[,2]), as.numeric(r.degree[,3]), pch = 16, col = alpha("red", 0.5))
points(as.numeric(r.betweenness[,2]), as.numeric(r.betweenness[,3]), pch = 16, col = alpha("blue", 0.5))
hist(r.random[101:150,3])
hist(r.random[51:100,3])
hist(r.random[151:200,3])
hist(r.random[201:250,3])
e^8
hist(r.degree[101:150,3])
par(mfrow = c(2,2))
hist(r.degree[1:50,3])
hist(r.degree[51:100,3])
hist(r.degree[101:150,3])
hist(r.degree[151:200,3])
par(mfrow = c(2,2))
hist(r.random[1:50,3])
hist(r.random[51:100,3])
hist(r.random[101:150,3])
hist(r.random[151:200,3])
par(mfrow = c(1,1))
par(mfrow = c(2,2))
hist(r.betweenness[1:50,3])
hist(r.betweenness[51:100,3])
hist(r.betweenness[101:150,3])
hist(r.betweenness[151:200,3])
par(mfrow = c(1,1))
