betas = 0.25,
rho = (1/6) * 0.4,            # Rate of exposed infection
sigma = 1/(6),
epsilon = (1/6) * 0.6,        # Rate of exposed asymptomatic infection
gamma =  1/(6),               # Rate of infectious dormancy
delta =  1/(52),         # Rate of dormancy
birth = 0.000352,             # Birth rate per week
death = 0.000352,              # Death rate per per week
vacc = 0                  # Percent of the population to be vaccination
)
init.values = c(S = 0.9998, E=0, Ia = 0.0001, Is=0.0001, D = 0.0, V=0)
times = seq(0, 52*10, by = 0.1)
# The differential equation model for EBV.
SEID = function(time, y.values, parameters) {
with(as.list(c(y.values, parameters)), {
dS.dt = - betaa * S * Ia - betas * S * Is  + birth * (S + E + Ia + Is + D+V) - (S * death) - (S * vacc)
dE.dt = betaa * S * Ia + betas * S * Is - epsilon * E - rho * E - (E * death)
dIa.dt = epsilon * E + delta * D - gamma * Ia - (Ia * death)
dIs.dt = rho * E - Is * sigma - Is * death
dD.dt = gamma * Ia + sigma * Is - delta * D - (D * death)
dV.dt = S * vacc - V * death
return(list(c(dS.dt, dE.dt, dIa.dt, dIs.dt, dD.dt, dV.dt)))
})
}
out <- as.data.frame(ode(func = SEID, y = init.values,
parms = pars, times = times))
out[,2:7] <- out[,2:7] /( rowSums(out[,2:7]))
# Figure 1 ------------------------------------------------------
matplot(out$time, out[ ,2:6], type = "l",
main = "EBV Infection in Population",
xlab="Time (Weeks)",
ylab="Proportion of the population",
lwd = 3,
lty = 1, ylim=c(0,1))
legend("right", c("Susceptible",  "Exposed", "Asymptomatic Infectious", "Symptomatic Infectious", "Dormant"),
col = 1:5, lty = 1, lwd = 3, cex =.75)
abline(h=1, lty="dotted")
abline(h=0, lty="dotted")
# Equilibrium ----------------------------------------------------
rhs <- function(p)  {
# Sadly, it looks like the parameters
# need to be included here, as part of
# the right hand side...
betaa =  0.5                    # Rate of exposure
betas = 0.25
rho = (1/6) * 0.4             # Rate of exposed infection
sigma = 1/(6)
epsilon = (1/6) * 0.6         # Rate of exposed asymptomatic infection
gamma =  1/(6)                # Rate of infectious dormancy
delta =  1/(300 / 7)          # Rate of dormancy
birth = 0.000352              # Birth rate per week
death = 0.000352              # Death rate per per week
S <- p[1]  # We declare that the state variables are
E <- p[2]  # passed to the function rhs in the vector p
Ia <- p[3]
Is <- p[4]
D <- p[5]
r <- numeric()  # r will hold the values returned by the rhs
# on input p
r[1] <- - betaa * S * Ia - betas * S * Is  + birth * (S + E + Ia + Is + D) - (S * death)
r[2] <- betaa * S * Ia + betas * S * Is - epsilon * E - rho * E - (E * death)
r[3] <-  epsilon * E + delta * D - gamma * Ia - (Ia * death)
r[4] <-  rho * E - Is * sigma - Is * death
r[5] <-  gamma * Ia + sigma * Is - delta * D - (D * death)
return(r)  # Return the value of r
}
p0 <- out[length(out[,1]),2:6] # An initial guess as to the solution
class(p0) <- "numeric"
out <- as.data.frame(ode(func = SEID, y = p0,
parms = pars, times = times))
out[,2:7] <- out[,2:7] /( rowSums(out[,2:7]))
# Figure 1 ------------------------------------------------------
matplot(out$time, out[ ,2:6], type = "l",
main = "EBV Infection in Population",
xlab="Time (Weeks)",
ylab="Proportion of the population",
lwd = 3,
lty = 1, ylim=c(0,1))
legend("right", c("Susceptible",  "Exposed", "Asymptomatic Infectious", "Symptomatic Infectious", "Dormant"),
col = 1:5, lty = 1, lwd = 3, cex =.75)
abline(h=1, lty="dotted")
abline(h=0, lty="dotted")
# -------------------------------
ans <- multiroot(f = rhs, start = p0) # This calls the solver
ans
Sstar = ans$root[1]
Estar = ans$root[2]
Iastar = ans$root[3]
Isstar = ans$root[4]
Dstar = ans$root[5]
mod <- function (t = 0, y = c(0,0,0,0,0), parms = NULL)
{
# Sadly, it looks like the parameters
# need to be included here, as part of
# the right hand side...
betaa =  0.5                    # Rate of exposure
betas = 0.25
rho = (1/6) * 0.4             # Rate of exposed infection
sigma = 1/(6)
epsilon = (1/6) * 0.6         # Rate of exposed asymptomatic infection
gamma =  1/(6)                # Rate of infectious dormancy
delta =  1/(300 / 7)          # Rate of dormancy
birth = 0.000352              # Birth rate per week
death = 0.000352              # Death rate per per week
S <- y[1]  # We declare that the state variables are
E <- y[2]  # passed to the function rhs in the vector p
Ia <- y[3]
Is <- y[4]
D <- y[5]
r <- numeric()  # r will hold the values returned by the rhs
# on input p
r[1] <- - betaa * S * Ia - betas * S * Is  + birth * (S + E + Ia + Is + D) - (S * death)
r[2] <- betaa * S * Ia + betas * S * Is - epsilon * E - rho * E - (E * death)
r[3] <-  epsilon * E + delta * D - gamma * Ia - (Ia * death)
r[4] <-  rho * E - Is * sigma - Is * death
r[5] <-  gamma * Ia + sigma * Is - delta * D - (D * death)
return(r)
}
q0 = c(Sstar,Estar,Iastar,Isstar,Dstar)
JJ <- jacobian.full(y = q0, func = mod)
JJ
eigenvalues = eigen(JJ)$values
print(eigenvalues)
# Algorithmicly determine if it is stable.
eigensum = 0
abseigen = 0
for (v in 1:length(eigenvalues)) {
eigensum = eigensum + Re(eigenvalues[v])
print(Re(eigenvalues[v]))
abseigen = abseigen + abs(Re(eigenvalues[v]))
}
if (abs(eigensum) == abseigen) {
print("The equilibrium is stable")
} else {
print("The equilibrium NOT stable!")
}
library(deSolve)
library(rootSolve)
rm(list=ls())
# Parameters and inital values. Assume a population of 1000.
pars = c(
betaa =  0.5,                   # Rate of exposure
betas = 0.25,
rho = (1/6) * 0.4,            # Rate of exposed infection
sigma = 1/(6),
epsilon = (1/6) * 0.6,        # Rate of exposed asymptomatic infection
gamma =  1/(6),               # Rate of infectious dormancy
delta =  1/(52),         # Rate of dormancy
birth = 0.000352,             # Birth rate per week
death = 0.000352,              # Death rate per per week
vacc = 0                  # Percent of the population to be vaccination
)
init.values = c(S = 1, E=0, Ia = 0.001, Is=0.001, D = 0.0, V=0)
times = seq(0, 52*10, by = 0.1)
# The differential equation model for EBV.
SEID = function(time, y.values, parameters) {
with(as.list(c(y.values, parameters)), {
dS.dt = - betaa * S * Ia - betas * S * Is  + birth * (S + E + Ia + Is + D+V) - (S * death) - (S * vacc)
dE.dt = betaa * S * Ia + betas * S * Is - epsilon * E - rho * E - (E * death)
dIa.dt = epsilon * E + delta * D - gamma * Ia - (Ia * death)
dIs.dt = rho * E - Is * sigma - Is * death
dD.dt = gamma * Ia + sigma * Is - delta * D - (D * death)
dV.dt = S * vacc - V * death
return(list(c(dS.dt, dE.dt, dIa.dt, dIs.dt, dD.dt, dV.dt)))
})
}
out <- as.data.frame(ode(func = SEID, y = init.values,
parms = pars, times = times))
out[,2:7] <- out[,2:7] /( rowSums(out[,2:7]))
# Figure 1 ------------------------------------------------------
matplot(out$time, out[ ,2:6], type = "l",
main = "EBV Infection in Population",
xlab="Time (Weeks)",
ylab="Proportion of the population",
lwd = 3,
lty = 1, ylim=c(0,1))
legend("right", c("Susceptible",  "Exposed", "Asymptomatic Infectious", "Symptomatic Infectious", "Dormant"),
col = 1:5, lty = 1, lwd = 3, cex =.75)
abline(h=1, lty="dotted")
abline(h=0, lty="dotted")
# Equilibrium ----------------------------------------------------
rhs <- function(p)  {
# Sadly, it looks like the parameters
# need to be included here, as part of
# the right hand side...
betaa =  0.5                    # Rate of exposure
betas = 0.25
rho = (1/6) * 0.4             # Rate of exposed infection
sigma = 1/(6)
epsilon = (1/6) * 0.6         # Rate of exposed asymptomatic infection
gamma =  1/(6)                # Rate of infectious dormancy
delta =  1/(300 / 7)          # Rate of dormancy
birth = 0.000352              # Birth rate per week
death = 0.000352              # Death rate per per week
S <- p[1]  # We declare that the state variables are
E <- p[2]  # passed to the function rhs in the vector p
Ia <- p[3]
Is <- p[4]
D <- p[5]
r <- numeric()  # r will hold the values returned by the rhs
# on input p
r[1] <- - betaa * S * Ia - betas * S * Is  + birth * (S + E + Ia + Is + D) - (S * death)
r[2] <- betaa * S * Ia + betas * S * Is - epsilon * E - rho * E - (E * death)
r[3] <-  epsilon * E + delta * D - gamma * Ia - (Ia * death)
r[4] <-  rho * E - Is * sigma - Is * death
r[5] <-  gamma * Ia + sigma * Is - delta * D - (D * death)
return(r)  # Return the value of r
}
p0 <- out[length(out[,1]),2:6] # An initial guess as to the solution
class(p0) <- "numeric"
out <- as.data.frame(ode(func = SEID, y = p0,
parms = pars, times = times))
out[,2:7] <- out[,2:7] /( rowSums(out[,2:7]))
# Figure 1 ------------------------------------------------------
matplot(out$time, out[ ,2:6], type = "l",
main = "EBV Infection in Population",
xlab="Time (Weeks)",
ylab="Proportion of the population",
lwd = 3,
lty = 1, ylim=c(0,1))
legend("right", c("Susceptible",  "Exposed", "Asymptomatic Infectious", "Symptomatic Infectious", "Dormant"),
col = 1:5, lty = 1, lwd = 3, cex =.75)
abline(h=1, lty="dotted")
abline(h=0, lty="dotted")
# -------------------------------
ans <- multiroot(f = rhs, start = p0) # This calls the solver
ans
Sstar = ans$root[1]
Estar = ans$root[2]
Iastar = ans$root[3]
Isstar = ans$root[4]
Dstar = ans$root[5]
mod <- function (t = 0, y = c(0,0,0,0,0), parms = NULL)
{
# Sadly, it looks like the parameters
# need to be included here, as part of
# the right hand side...
betaa =  0.5                    # Rate of exposure
betas = 0.25
rho = (1/6) * 0.4             # Rate of exposed infection
sigma = 1/(6)
epsilon = (1/6) * 0.6         # Rate of exposed asymptomatic infection
gamma =  1/(6)                # Rate of infectious dormancy
delta =  1/(300 / 7)          # Rate of dormancy
birth = 0.000352              # Birth rate per week
death = 0.000352              # Death rate per per week
S <- y[1]  # We declare that the state variables are
E <- y[2]  # passed to the function rhs in the vector p
Ia <- y[3]
Is <- y[4]
D <- y[5]
r <- numeric()  # r will hold the values returned by the rhs
# on input p
r[1] <- - betaa * S * Ia - betas * S * Is  + birth * (S + E + Ia + Is + D) - (S * death)
r[2] <- betaa * S * Ia + betas * S * Is - epsilon * E - rho * E - (E * death)
r[3] <-  epsilon * E + delta * D - gamma * Ia - (Ia * death)
r[4] <-  rho * E - Is * sigma - Is * death
r[5] <-  gamma * Ia + sigma * Is - delta * D - (D * death)
return(r)
}
q0 = c(Sstar,Estar,Iastar,Isstar,Dstar)
JJ <- jacobian.full(y = q0, func = mod)
JJ
eigenvalues = eigen(JJ)$values
print(eigenvalues)
# Algorithmicly determine if it is stable.
eigensum = 0
abseigen = 0
for (v in 1:length(eigenvalues)) {
eigensum = eigensum + Re(eigenvalues[v])
print(Re(eigenvalues[v]))
abseigen = abseigen + abs(Re(eigenvalues[v]))
}
if (abs(eigensum) == abseigen) {
print("The equilibrium is stable")
} else {
print("The equilibrium NOT stable!")
}
library(deSolve)
library(rootSolve)
rm(list=ls())
# Parameters and inital values. Assume a population of 1000.
pars = c(
betaa =  0.5,                   # Rate of exposure
betas = 0.25,
rho = (1/6) * 0.4,            # Rate of exposed infection
sigma = 1/(6),
epsilon = (1/6) * 0.6,        # Rate of exposed asymptomatic infection
gamma =  1/(6),               # Rate of infectious dormancy
delta =  1/(52),         # Rate of dormancy
birth = 0.000352,             # Birth rate per week
death = 0.000352,              # Death rate per per week
vacc = 0                  # Percent of the population to be vaccination
)
init.values = c(S = 0.998, E=0, Ia = 0.001, Is=0.001, D = 0.0, V=0)
times = seq(0, 52*10, by = 0.1)
# The differential equation model for EBV.
SEID = function(time, y.values, parameters) {
with(as.list(c(y.values, parameters)), {
dS.dt = - betaa * S * Ia - betas * S * Is  + birth * (S + E + Ia + Is + D+V) - (S * death) - (S * vacc)
dE.dt = betaa * S * Ia + betas * S * Is - epsilon * E - rho * E - (E * death)
dIa.dt = epsilon * E + delta * D - gamma * Ia - (Ia * death)
dIs.dt = rho * E - Is * sigma - Is * death
dD.dt = gamma * Ia + sigma * Is - delta * D - (D * death)
dV.dt = S * vacc - V * death
return(list(c(dS.dt, dE.dt, dIa.dt, dIs.dt, dD.dt, dV.dt)))
})
}
out <- as.data.frame(ode(func = SEID, y = init.values,
parms = pars, times = times))
out[,2:7] <- out[,2:7] /( rowSums(out[,2:7]))
# Figure 1 ------------------------------------------------------
matplot(out$time, out[ ,2:6], type = "l",
main = "EBV Infection in Population",
xlab="Time (Weeks)",
ylab="Proportion of the population",
lwd = 3,
lty = 1, ylim=c(0,1))
legend("right", c("Susceptible",  "Exposed", "Asymptomatic Infectious", "Symptomatic Infectious", "Dormant"),
col = 1:5, lty = 1, lwd = 3, cex =.75)
abline(h=1, lty="dotted")
abline(h=0, lty="dotted")
# Equilibrium ----------------------------------------------------
rhs <- function(p)  {
# Sadly, it looks like the parameters
# need to be included here, as part of
# the right hand side...
betaa =  0.5                    # Rate of exposure
betas = 0.25
rho = (1/6) * 0.4             # Rate of exposed infection
sigma = 1/(6)
epsilon = (1/6) * 0.6         # Rate of exposed asymptomatic infection
gamma =  1/(6)                # Rate of infectious dormancy
delta =  1/(300 / 7)          # Rate of dormancy
birth = 0.000352              # Birth rate per week
death = 0.000352              # Death rate per per week
S <- p[1]  # We declare that the state variables are
E <- p[2]  # passed to the function rhs in the vector p
Ia <- p[3]
Is <- p[4]
D <- p[5]
r <- numeric()  # r will hold the values returned by the rhs
# on input p
r[1] <- - betaa * S * Ia - betas * S * Is  + birth * (S + E + Ia + Is + D) - (S * death)
r[2] <- betaa * S * Ia + betas * S * Is - epsilon * E - rho * E - (E * death)
r[3] <-  epsilon * E + delta * D - gamma * Ia - (Ia * death)
r[4] <-  rho * E - Is * sigma - Is * death
r[5] <-  gamma * Ia + sigma * Is - delta * D - (D * death)
return(r)  # Return the value of r
}
p0 <- out[length(out[,1]),2:6] # An initial guess as to the solution
class(p0) <- "numeric"
out <- as.data.frame(ode(func = SEID, y = p0,
parms = pars, times = times))
out[,2:7] <- out[,2:7] /( rowSums(out[,2:7]))
# Figure 1 ------------------------------------------------------
matplot(out$time, out[ ,2:6], type = "l",
main = "EBV Infection in Population",
xlab="Time (Weeks)",
ylab="Proportion of the population",
lwd = 3,
lty = 1, ylim=c(0,1))
legend("right", c("Susceptible",  "Exposed", "Asymptomatic Infectious", "Symptomatic Infectious", "Dormant"),
col = 1:5, lty = 1, lwd = 3, cex =.75)
abline(h=1, lty="dotted")
abline(h=0, lty="dotted")
# -------------------------------
ans <- multiroot(f = rhs, start = p0) # This calls the solver
ans
Sstar = ans$root[1]
Estar = ans$root[2]
Iastar = ans$root[3]
Isstar = ans$root[4]
Dstar = ans$root[5]
mod <- function (t = 0, y = c(0,0,0,0,0), parms = NULL)
{
# Sadly, it looks like the parameters
# need to be included here, as part of
# the right hand side...
betaa =  0.5                    # Rate of exposure
betas = 0.25
rho = (1/6) * 0.4             # Rate of exposed infection
sigma = 1/(6)
epsilon = (1/6) * 0.6         # Rate of exposed asymptomatic infection
gamma =  1/(6)                # Rate of infectious dormancy
delta =  1/(300 / 7)          # Rate of dormancy
birth = 0.000352              # Birth rate per week
death = 0.000352              # Death rate per per week
S <- y[1]  # We declare that the state variables are
E <- y[2]  # passed to the function rhs in the vector p
Ia <- y[3]
Is <- y[4]
D <- y[5]
r <- numeric()  # r will hold the values returned by the rhs
# on input p
r[1] <- - betaa * S * Ia - betas * S * Is  + birth * (S + E + Ia + Is + D) - (S * death)
r[2] <- betaa * S * Ia + betas * S * Is - epsilon * E - rho * E - (E * death)
r[3] <-  epsilon * E + delta * D - gamma * Ia - (Ia * death)
r[4] <-  rho * E - Is * sigma - Is * death
r[5] <-  gamma * Ia + sigma * Is - delta * D - (D * death)
return(r)
}
q0 = c(Sstar,Estar,Iastar,Isstar,Dstar)
JJ <- jacobian.full(y = q0, func = mod)
JJ
eigenvalues = eigen(JJ)$values
print(eigenvalues)
# Algorithmicly determine if it is stable.
eigensum = 0
abseigen = 0
for (v in 1:length(eigenvalues)) {
eigensum = eigensum + Re(eigenvalues[v])
print(Re(eigenvalues[v]))
abseigen = abseigen + abs(Re(eigenvalues[v]))
}
if (abs(eigensum) == abseigen) {
print("The equilibrium is stable")
} else {
print("The equilibrium NOT stable!")
}
q0
sum(10)
sum(q0)
rhs <- function(p)  {
# Sadly, it looks like the parameters
# need to be included here, as part of
# the right hand side...
betaa =  0.5                    # Rate of exposure
betas = 0.25
rho = (1/6) * 0.4             # Rate of exposed infection
sigma = 1/(6)
epsilon = (1/6) * 0.6         # Rate of exposed asymptomatic infection
gamma =  1/(6)                # Rate of infectious dormancy
delta =  1/(52)          # Rate of dormancy
birth = 0.000352              # Birth rate per week
death = 0.000352              # Death rate per per week
S <- p[1]  # We declare that the state variables are
E <- p[2]  # passed to the function rhs in the vector p
Ia <- p[3]
Is <- p[4]
D <- p[5]
r <- numeric()  # r will hold the values returned by the rhs
# on input p
r[1] <- - betaa * S * Ia - betas * S * Is  + birth * (S + E + Ia + Is + D) - (S * death)
r[2] <- betaa * S * Ia + betas * S * Is - epsilon * E - rho * E - (E * death)
r[3] <-  epsilon * E + delta * D - gamma * Ia - (Ia * death)
r[4] <-  rho * E - Is * sigma - Is * death
r[5] <-  gamma * Ia + sigma * Is - delta * D - (D * death)
return(r)  # Return the value of r
}
p0 <- out[length(out[,1]),2:6] # An initial guess as to the solution
p0
class(p0) <- "numeric"
p0
sum(p0)
matplot(out$time, out[ ,2:6], type = "l",
main = "EBV Infection in Population",
xlab="Time (Weeks)",
ylab="Proportion of the population",
lwd = 3,
lty = 1, ylim=c(0,1))
legend("right", c("Susceptible",  "Exposed", "Asymptomatic Infectious", "Symptomatic Infectious", "Dormant"),
col = 1:5, lty = 1, lwd = 3, cex =.75)
abline(h=1, lty="dotted")
abline(h=0, lty="dotted")
# -------------------------------
ans <- multiroot(f = rhs, start = p0) # This calls the solver
ans
Sstar = ans$root[1]
Estar = ans$root[2]
Iastar = ans$root[3]
Isstar = ans$root[4]
Dstar = ans$root[5]
q0 = c(Sstar,Estar,Iastar,Isstar,Dstar)
q0
sum(q0)
JJ <- jacobian.full(y = q0, func = mod)
JJ
eigenvalues = eigen(JJ)$values
print(eigenvalues)
# Algorithmicly determine if it is stable.
eigensum = 0
abseigen = 0
for (v in 1:length(eigenvalues)) {
eigensum = eigensum + Re(eigenvalues[v])
print(Re(eigenvalues[v]))
abseigen = abseigen + abs(Re(eigenvalues[v]))
}
if (abs(eigensum) == abseigen) {
print("The equilibrium is stable")
} else {
print("The equilibrium NOT stable!")
}
q0\
q0
out <- as.data.frame(ode(func = SEID, y = q0,
parms = pars, times = times))
out <- as.data.frame(ode(func = SEID, y = q0,
parms = pars, times = times))
q0
out <- as.data.frame(ode(func = SEID, y = c(q0,0),
parms = pars, times = times))
setwd("~/projects/airport_flu_modeling")
library("maps")
airports = read.csv("data/airports.dat")
data = read.csv("betweenness.csv")
colorValues = data$betweenness*10000
ramp <- colorRampPalette(c("blue","red"))
colors = ramp(max(colorValues))
data = data[order(data$betweenness),]
map("world", xlim=c(-180,180), ylim=c(-90,90), mar=c(0,0,0,0))
points(x=data$lon, y=data$lat, pch=16, cex=0.4, col=colors[colorValues])
